module make-occurrences

imports
  signatures/-
  analysis
  
signature
  constructors
    LetOccurrence: Occurrence * Exp * Exp -> Exp
    VarOccurrence: Occurrence -> Exp
  
  sorts
    Occurrence Namespace TermIndex
  
  constructors
    TermIndex : String * Int -> TermIndex
    NoNamespace: Namespace
    Occurrence : Namespace * Name * TermIndex -> Occurrence
  
  constructors
    Occ2ID: Occurrence -> Identifier 
    //        inherit * traits    * slot ids         * code 
    ObjectLS: Inherit * List(Use) * List(Identifier) * List(Statement) -> Object
    //         name       * dunno            * annos       * params           * typein        * typeout * locals           * code 
    MethodLS : Identifier * List(Identifier) * Annotations * List(Identifier) * List(TypeExp) * TypeExp * List(Identifier) * List(Statement) -> Declaration
    //       params           * types         * locals           * code
    BlockLS: List(Identifier) * List(TypeExp) * List(Identifier) * List(Statement) -> Exp
    SlotWrite: Identifier * Exp -> Statement
    SlotRead: Identifier -> Statement
rules

  debug-show-full-transform:
    (_, _, ast, path, _) -> (filename, result)
    with
      filename := <guarantee-extension(|"transformed.aterm")> path;
      result   := <full-transform> ast

  full-transform =
    desugar-complete;
    desugar-wildcard-decls;
    desugar-objects;
    desugar-constructors;
    desugar-methods
//    make-occurrences

// -------------

  desugar-wildcard-decls = alltd(desugar-wildcard-decl)
  
  desugar-wildcard-decl:
    Declaration(VariableL(WildCard(), _, _, e)) ->
      Expression(e)

  desugar-wildcard-decl:
    Declaration(ConstantL(WildCard(), _, _, e)) ->
      Expression(e)

// --------------

  desugar-objects = bottomup(try(desugar-obj-fields))
  
  desugar-obj-fields:
    ObjectL(inherit, uses, code) -> ObjectLS(inherit, uses, slots, code')
    where
      (code', slots) := <map(desugar-obj-field <+ !([<id>], [])); unzip; (concat, concat)> code
  
  desugar-obj-field:
    Declaration(VariableL(fid@ID(_), _,  Annotations(annos), e)) ->
      ([init-stm, getter, setter, internal-setter], [sid])
    where
      sid := <mk-slotname> fid;
      init-stm := <slot-assign-call> (fid, e);
      internal-setter := <slot-internal-setter> fid;
      getter := <slot-getter> (fid, annos);
      setter := <slot-setter> (fid, annos)
  
  desugar-obj-field:
    Declaration(ConstantL(fid@ID(_), _,  Annotations(annos), e)) ->
      ([init-stm, getter, internal-setter], [sid])
    where
      sid := <mk-slotname> fid;
      init-stm := <slot-assign-call> (fid, e);
      internal-setter := <slot-internal-setter> fid;
      getter := <slot-getter> (fid, annos)
  
  slot-assign-call:
    (fid, e) -> Expression(MCallL(<mk-internal-settername> fid, [e]))
  
  slot-internal-setter:
    fid ->
      Declaration(MethodL(
        <mk-internal-settername> fid, [], Annotations([Confidential()]), [ID("$px")], [], <no-type>, 
          [SlotWrite(<mk-slotname> fid, MCallL(ID("$px"), []))]))
  
  slot-getter:
    (fid, annos) ->
      Declaration(MethodL(
        <mk-gettername> fid, [], <mk-getter-annos> annos, [], [], <no-type>,
          [SlotRead(<mk-slotname> fid)]))
  
  slot-setter:
    (fid, annos) ->
      Declaration(MethodL(
        <mk-settername> fid, [], <mk-setter-annos> annos, [ID("$pv")], [], <no-type>,
          [SlotWrite(<mk-slotname> fid, MCallL(ID("$pv"), []))]))
  
  mk-slotname:
    ID(x) -> ID($[#_slot_#_[x]])
  
  mk-gettername:
    ID(x) -> ID(x)
  
  mk-settername:
    ID(x) -> ID($[[x]:=(_)])
  
  mk-internal-settername:
    ID(x) -> ID($[#_set_#_[x]])
  
  mk-getter-annos =
    filter(?Public() + ?Confidential() + \ Readable() -> Public() \);
    foldr(!Confidential(), \ (_, Public()) -> Public() \ + \ (a, Confidential()) -> a \);
    !Annotations([<id>])
  
  mk-setter-annos =
    filter(?Public() + ?Confidential() + \ Writable() -> Public() \);
    foldr(!Confidential(), \ (_, Public()) -> Public() \ + \ (a, Confidential()) -> a \);
    !Annotations([<id>])
  
  no-type = !TypeID(ID("Unknown"), NoTypeArg())

// --------------

  desugar-constructors = bottomup(try(desugar-constructor))

  desugar-constructor:
    ObjectLS(inherit, uses, slots, code) -> ObjectLS(inherit, uses, slots, <conc> (decls-code, [ctr]))
    where
      (decls-code, constr-code) := <partition(?Declaration(_) <+ ?Dialect(_))> code;
      ctr := <mk-constructor> constr-code
  
  mk-constructor:
    ctr-code -> Declaration(MethodL(ID("#ctr"), [], Annotations([Confidential()]), [], [], <no-type>, ctr-code))

// --------------

  desugar-methods = bottomup(try(desugar-method))
  
  desugar-method:
    MethodL(ID(x), dunno, annos, params, types-in, type-out, code) ->
      MethodLS(ID(x), dunno, annos, params, types-in, type-out, locals, code')
    where
      locals := <filter(get-decl-id)> code;
      code'  := <map(try(desugar-method-local))> code
  
  desugar-method:
    BlockL(params, types, code) -> BlockLS(params, types, locals, code')
    where
      locals := <filter(get-decl-id)> code;
      code'  := <map(try(desugar-method-local))> code
  
  get-decl-id:
    Declaration(VariableL(vid@ID(_), _,  _, _)) -> vid

  get-decl-id:
    Declaration(ConstantL(vid@ID(_), _,  _, _)) -> vid

  desugar-method-local:
    Declaration(VariableL(vid@ID(x), _, _, e)) -> Expression(MCallL(ID($[[x]:=(_)]), [e]))

  desugar-method-local:
    Declaration(ConstantL(vid@ID(x), _, _, e)) -> Expression(MCallL(ID($[[x]:=(_)]), [e]))

// --------------

  make-occurrences = {| FreshCounter:
    rules(FreshCounter: _ -> 1);
    alltd(make-occurrence)
  |}
  
  fresh =
    FreshCounter;
    inc; ?idx;
    rules(FreshCounter: _ -> idx)
  
  make-occurrence:
    ID(x) -> Occ2ID(Occurrence(NoNamespace(), x, TermIndex(x, <fresh>)))
  
