module trans/semantics

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig
  
  trans/values
  trans/store
  trans/environment
  trans/lookup

signature

  arrows
    Program -init-> V

    Exp --> V
    CodeSequence --> V
    Declaration --> V
    Assignment --> V
    CallArgs --> V
    List(CodeSequence) --> V
    Params --> List(String)

    Inherit --> Ref
    
    List(Exp) -ea-> List(V)
    
  constructors
    
    Call: M * List(V) --> V
    
    saveConst: String * V * Members --> Members
    saveConstants: List(String) * List(V) * Members --> Members
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativePrint: V -> V
    
rules
  
  Expression(e) --> e.
  Declaration(e) --> e.
  Assignment(e) --> e.
  Wrapped(v) --> v.
  
  ICS(i) -s-> i.
  IDS(i) -s-> i.

  Number(s) --> NumV(parseNumber(s)).
  ArgNumber(s) --> NumV(parseNumber(s)).
  ArgString(s) --> StringV(s).
  String(s) --> StringV(s).
  
  Program(cs, _) -init-> cs'
    where
      CS ICS(fresh), DS IDS(fresh) |- allocateObject(NoObject()) :: OHeap {}, MHeap {} --> r;
      CS ICS(r), DS IDS(r) |- cs :: OHeap {}, MHeap {} --> cs' :: OHeap _, MHeap _.
  
  cs : List(CodeSequence) --> v'
    where
      case cs of {
        [] =>
          Done() => v'
        [code | [] ] =>
          code --> v'
        [code | cs'] =>
          code --> _;
          cs' --> v'
      }.

  csv |- MCallCanonicalL(receiver, name, _, args) --> v
    where
       csv |- receiver --> ObjectRef(i');
       csv, DS IDS(i') |- lookup(name) --> m;
       DS IDS(i') |- Call(m, args) --> v.
  
  MCallImplL("base_print", _, [v]) --> v
    where
      nativePrint(v) => _.
  
  MCallImplL(name, _, vs) --> Call(lookup(name), vs)
    where
      print(StringV("calling impl")) => _.
  
  dsv |- Constant(name, _, _, v) --> Done()
    where
      readObject(dsv) --> Object(enc, sup, tbl);
      allocateMethod(Method([], [Wrapped(v)], dsv)) --> iMethod;
      writeObject(dsv, Object(enc, sup, {name |--> iMethod, tbl} )) --> _.
  // create addmember rule to abstract this
  
  dsv |- MethodDeclL(_, name, _, _, pNames, _, _, code, _) --> Done()
    where
      allocateMethod(Method(pNames, code, dsv)) --> iMethod;
      readObject(dsv) --> Object(enc, sup, tbl);
      writeObject(dsv, Object(enc, sup, {name |--> iMethod, tbl})) --> _.
  
  dsv |- ObjectDecl(inherit, [], cs) --> ObjectRef(i')
    where
      allocateObject(Object(dsv, inherit, {})) --> i'; // allocate should create object
      CS ICS(i'), DS IDS(i') |- cs --> _. // addr -> objecref
  
//  Call(Method(names, code, ds), values) --> v
//  where
//    DS IDS(ds) |- with-binds(binds(names, values), code) --> v.
//  
//  ics |- with-binds(binds, code) --> v
//  where
//    readObject(ics) --> Object(enc, sup, tbl);
//    write(Object(enc, sup, tbl + binds)) --> _;
//    code --> v;
//    write(Object(enc, sup, tbl + tbl')) --> _.
//    
    // add inner object as env for method
  
  csv |- Call(Method(names, code, ds), values) --> v
    where
      readObject(csv) --> Object(enc, sup, tbl);
      saveConstants(names, values, tbl) --> tbl';
      writeObject(csv, Object(enc, sup, tbl')) --> _;
      DS IDS(ds) |- code --> v;
      writeObject(csv, Object(enc, sup, tbl)) --> _. // restore
  
  saveConstants(names : List(String), values: List(V), tbl : Members) --> tbl'''
    where
      case names of {
        [] =>
          tbl => tbl'''
        [n | ns] =>
          values => [v|vs];
          saveConst(n, v, tbl) --> tbl';
          saveConstants(ns, vs, tbl) --> tbl'';
          {tbl'', tbl'} => tbl'''
      }.
      
  dsv |- saveConst(name, v, tbl) :: MH --> tbl' :: MH'
    where
      fresh => iMethod;
      writeMethod(iMethod, Method([], [Wrapped(v)], dsv)) :: MH --> _ :: MH';
      {name |--> iMethod, tbl} => tbl'.
      
  [] : List(Exp) -ea-> [].
  
  [arg] : List(Exp) -ea-> [v]
    where
      arg --> v.
  
  [arg | more] : List(Exp) -ea-> [v | vs]
    where
      arg --> v;
      more -ea-> vs : List(V).

  Inherit(e, _, _) --> r // change to default arrow
    where
      e --> ObjectRef(r).

  NoInherit() --> r
    where
      allocateObject(NoObject()) --> r.
