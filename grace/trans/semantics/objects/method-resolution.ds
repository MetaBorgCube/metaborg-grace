module trans/semantics/objects/method-resolution

imports
  trans/semantics/objects/path
  trans/semantics/objects/obj-repr

signature
  components
    PIDX : Int
    
  arrows
    resolve-top(Identifier, Loc) --> ResPath
    
    resolve(Identifier, Loc) --> ResPath
    
    resolve-in-parent(Identifier, Parent) --> ResPath
    
    resolve-in-outer(Identifier, Loc) --> ResPath
    resolve-in-parents(Identifier, Parents) --> ResPath
    
    disambiguate-paths(Identifier, ResPath, ResPath) --> ResPath

rules

  resolve-top(x, S') --> path
  where
    resolve(x, S') --> path;
    case path of {
      [] =>
        name(x) --> name;
        halt-error("Unknown method " ++ name) --> _
      otherwise =>
    }

  resolve(x, S') --> [PL(x)]
  where
    read(S') --> Obj(_, _, attrs);
    attrs[x?] == true
  
  O |- resolve(x, S') --> path
  where
    read(S') --> o@Obj(O', parents, attrs);
    attrs[x?] == false;
    O == O';
    O, PIDX 0 |- resolve-in-parents(x, parents) --> path-in-parent;
    /*
      the contextual Outer object is the Outer of the object we are looking up in.
      this means we are still looking up from within the object itself and may go to its
      surrounding lexical scope 
    */
    O, S' |- resolve-in-outer(x, S') --> path-in-outer;
    disambiguate-paths(x, path-in-parent, path-in-outer) --> path
  
  O |- resolve(x, S') --> path-in-parent
  where
    read(S') --> o@Obj(O', parents, attrs);
    attrs[x?] == false;
    O != O';
    O, PIDX 0 |- resolve-in-parents(x, parents) --> path-in-parent

  resolve-in-outer(_, S) --> []
  where
    read(S) --> Obj(O, _, _);
    is-stored(O) --> false

  resolve-in-outer(x, S) --> path
  where
    read(S) --> Obj(O, _, _);
    is-stored(O) --> true;
    read(O) --> Obj(OO, _, _);
    O OO |- resolve(x, O) --> out-path;
    path as [PO() | out-path] if path-found(out-path)
         or []

  resolve-in-parents(_, []) --> []
  
  PIDX |- resolve-in-parents(x, [parent | parents]) --> path
  where
    PIDX |- resolve-in-parent(x, parent) --> p-path;
    case path-found(p-path) : Bool of {
      true =>
        p-path => path
      otherwise =>
        PIDX addI(PIDX, 1) |- resolve-in-parents(x, parents) --> path
    }
    
  resolve-in-parent(x, (_, _, excludes)) --> []
  where
    excludes[x?] == true
  
  O, PIDX |- resolve-in-parent(x, (S', aliases, excludes)) --> path
  where
    excludes[x?] == false;
    aliases[x?] == true;
    aliases[x] => x';
    O |- resolve(x', S') --> parent-path;
    path as [PP(PIDX, x') | parent-path] if path-found(parent-path)
         or []
 
  O, PIDX |- resolve-in-parent(x, (S', aliases, excludes)) --> path
  where
    excludes[x?] == false;
    aliases[x?] == false;
    O |- resolve(x, S') --> parent-path;
    path as [PP(PIDX, x) | parent-path] if path-found(parent-path)
         or []


  disambiguate-paths(_, p@[_|_], []) --> p // parent
  
  disambiguate-paths(_, [], o@[_|_]) --> o // outer
  
  disambiguate-paths(x, p@[_|_], o@[_|_]) --> o // potentially ambiguous
  where
    path-strictly-inherited(p) --> strictly-inherited;
    path-strictly-lexical(o) --> strictly-lexical;
    case (strictly-inherited, strictly-lexical) of {
      (true, true) =>
        name(x) --> name;
        halt-error(name ++ " is both inherited, and defined in an enclosing scope") --> _
      otherwise =>
    }
  
  disambiguate-paths(_, [], []) --> [] // not found










