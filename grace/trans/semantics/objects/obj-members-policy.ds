module trans/semantics/objects/obj-members-policy

imports
  trans/semantics/store
  trans/semantics/objects/path
  trans/semantics/objects/obj-repr
  trans/semantics/runtime/natives
  trans/semantics/values

signature
  arrows
    policy-member-applies-to(Identifier) --> Bool
  
    policy-members-allow-duplicates() --> Bool
    policy-members-allow-duplicate-inherited() --> Bool
    policy-members-allow-shadow-lexical-local() --> Bool
    policy-members-allow-shadow-lexical-member() --> Bool
    policy-members-allow-shadow-lexical-inherited() --> Bool


    enforce-member-policy(Loc, Identifier) --> U
    check-member-duplicate(Identifier, ResPath) --> U
    check-member-duplicate-inherited(Identifier, ResPath) --> U
    check-members-shadow-lexical-local(Identifier, ResPath) --> U
    check-members-shadow-lexical-member(Identifier, ResPath) --> U
    check-members-shadow-lexical-inherited(Identifier, ResPath) --> U
    
rules
  
  policy-members-allow-duplicates() --> false
  policy-members-allow-duplicate-inherited() --> true
  policy-members-allow-shadow-lexical-local() --> false
  policy-members-allow-shadow-lexical-member() --> true
  policy-members-allow-shadow-lexical-inherited() --> true
  
rules
  
  policy-member-applies-to(x) --> notB(str-starts-with(name(x), "#"))
  
  enforce-member-policy(S, x) --> U()
  where
    case policy-member-applies-to(x) : Bool of {
      false =>
      true =>
        outer-addr(S) --> O;
        S, O |- resolve(x, S) --> x-path;
        case path-found(x-path) : Bool of {
          false =>
          otherwise =>
            check-member-duplicate(x, x-path) --> _;
            check-member-duplicate-inherited(x, x-path) --> _;
            check-members-shadow-lexical-local(x, x-path) --> _;
            check-members-shadow-lexical-member(x, x-path) --> _;
            check-members-shadow-lexical-inherited(x, x-path) --> _
      }
    }
  
  check-member-duplicate(x, path) --> U()
  where
    case policy-members-allow-duplicates() : Bool of {
      true =>
      false =>
        case path-local(path) : Bool of {
          true =>
            name(x) --> name;
            halt-error("Duplicate member '" ++ name ++ "'") --> _
          false =>
            case path-local-aliased(x, path) : Bool of {
              true =>
                name(x) --> name;
                halt-error("Duplicate member '" ++ name ++ "'") --> _
              false =>
            }
        }
    }
  
  check-member-duplicate-inherited(x, path) --> U()
  where
    case policy-members-allow-duplicate-inherited() : Bool of {
      true =>
      false =>
        case path-strictly-inherited(path) : Bool of {
          true =>
            name(x) --> name;
            halt-error("Member '" ++ name ++ "' overrides inherited member") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-local(x, _) --> U()
  where
    case policy-members-allow-shadow-lexical-local() : Bool of {
      true =>
      false =>
        case is-local(x) : Bool of {
          true =>
            name(x) --> name;
            halt-error("Member '" ++ name ++ "' shadows local variable in surrounding scope") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-member(x, x-path) --> U()
  where
    case policy-members-allow-shadow-lexical-member() : Bool of {
      true =>
      false =>
        case path-strictly-lexical(x-path) : Bool of {
          true =>
            name(x) --> name;
            halt-error("Member '" ++ name ++ "' shadows member defined in surrounding scope") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-inherited(x, x-path) --> U()
  where
    case policy-members-allow-shadow-lexical-inherited() : Bool of {
      true =>
      false =>
        case (path-lexical(x-path) : Bool, path-strictly-lexical(x-path) : Bool) of {
          (true, false) =>
            name(x) --> name;
            halt-error("Member '" ++ name ++ "' shadows member inherited into surrounding scope") --> _
          otherwise =>
        }
    }