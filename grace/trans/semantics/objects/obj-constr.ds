module trans/semantics/objects/obj-constr

imports
  trans/semantics/objects/obj-desugar
  trans/semantics/objects/obj-repr
  trans/semantics/objects/obj-init
//  trans/semantics/store
  trans/semantics/objects/obj-members-policy
//  trans/semantics/frames/frames-adapter
  
signature
  sorts
    EvalMode
  
  constructors
    // regular evaluation mode
    E: EvalMode
    // object building mode. carries the address of the object being constructed
    B: Frame -> EvalMode
  
  components
    EB : EvalMode
  
  arrows
    Exp -bld-> Frame
    List(LInherit) -bld-> List(Frame)
    defaults(List(Identifier)) --> Map(Occurrence, Val)
    mk-closures(LMethods) --> Map(Occurrence, Val)
    
//  arrows
//    Exp -bld-> Loc
//    add-parents(Loc, List(LInherit)) --> U
//    add-parent(Loc, LInherit) --> U
//    add-slots(Loc, LSlots) --> U
//    add-methods(Loc, LMethods) --> U
//    add-methods-aux(Loc, List(String), LMethods) --> U
    
rules

  Self() --> RefV(self-addr())
  
  Outer() --> RefV(outer-addr())

  MQCallOuter(e) --> RefV(outer-addr(S))
  where
    e --> RefV(S)

  o@ObjectLS(_, _, _, _) --> desugar-obj(o)
  
  o@LObj(_, _, _) --> RefV(S')
  where
    o -bld-> F;
//    enforce-closure-policy(S') --> _;
    // TODO: outer might not be necessary
    S S', O S |- init-obj(S') --> _

  S, O |- LObj(parents, slots, methods) -bld-> F
  where
    parents -bld-> import-Fs;
    { P() |--> [O], I() |--> import-Fs } => links;
    defaults(slots) --> slots-map;
    mk-closures(methods) --> methods-map;
    initFrame(links, {slots-map, methods-map}) --> F

//  LObj(parents, slots, methods) -bld-> F
//  where
//    init-slots(slots) --> islots;
//    mk-closures(methods) --> closures
    

  
  S, EB |- LObj(parents, slots, methods) -bld-> S'
  where
    allocate(Obj(S, [], {})) --> S';
    case EB of {
      B(S'') =>
      otherwise =>
        S' => S''
    };
    S S'', O S |- add-parents(S', parents) --> _;
    O S |- add-slots(S', slots) --> _;
    O S |- add-methods(S', methods) --> _

  add-parents(S', []) --> U()
  
  add-parents(S', [p | parents]) --> U()
  where
    add-parent(S', p) --> _;
    add-parents(S', parents) --> _
  
  S |- add-parent(S', LInherit(e, alias-map, exclude-map)) --> U()
  where
    EB B(S) |- e --> RefV(S);
    read(S') --> Obj(O, parents, attrs);
    update(S', Obj(O, [(S, alias-map, exclude-map) | parents], attrs)) --> _
  
  EB B(S) |- MCallRecvL(e, x, es) --> v
  where
    EB E() |- e --> recv;
    EB E() |- es --> vs;
    EB B(S) |- call-qualified(recv, x, vs) --> v
  
  add-slots(_, []) --> U()
  
  add-slots(S', [s | ss]) --> U()
  where
    default-value() --> v;
    read(S') --> Obj(O, parents, attrs);
    update(S', Obj(O, parents, {s |--> v, attrs})) --> _;
    add-slots(S', ss) --> _
  
  add-methods(_, []) --> U()
  
  add-methods(S', [ (m, decl) | ms]) --> add-methods(S', ms)
  where
//    enforce-member-policy(S', m) --> _;
    DObj DObj(S') |- method-closure(decl) --> clos;
    read(S') --> Obj(O, parents, attrs);
    update(S', Obj(O, parents, {m |--> clos, attrs})) --> _


