module trans/semantics/objects/obj-constr

imports
  trans/semantics/objects/obj-desugar
  trans/semantics/objects/obj-repr
  trans/semantics/objects/obj-init
  trans/semantics/store
  trans/semantics/objects/obj-members-policy
  
signature
  sorts
    EvalMode
  
  constructors
    // regular evaluation mode
    E: EvalMode
    // object building mode. carries the address of the object being constructed
    B: Addr -> EvalMode
  
  components
    EB : EvalMode
  
  arrows
    Exp -bld-> Addr
    add-parents(Addr, List(LInherit)) --> U
    add-parent(Addr, LInherit) --> U
    add-slots(Addr, LSlots) --> U
    add-methods(Addr, LMethods) --> U
    add-methods-aux(Addr, List(String), LMethods) --> U
    
rules

  Self() --> RefV(self-addr())
  
  Outer() --> RefV(outer-addr())

  MQCallOuter(e) --> RefV(outer-addr(S))
  where
    e --> RefV(S)

  o@ObjectL(_, _, _) --> desugar-obj(o)
  
  S |- o@LObj(_, _, _) --> RefV(S')
  where
    o -bld-> S';
    enforce-closure-policy(S') --> _;
    // TODO: outer might not be necessary
    S S', O S |- init-obj(S') --> _
  
  S, EB |- LObj(parents, slots, methods) -bld-> S'
  where
    allocate(Obj(S, [], {}, {})) --> S';
    case EB of {
      B(S'') =>
      otherwise =>
        S' => S''
    };
    S S'', O S |- add-parents(S', parents) --> _;
    O S |- add-slots(S', slots) --> _;
    O S |- add-methods(S', methods) --> _

  add-parents(S', []) --> U()
  
  add-parents(S', [p | parents]) --> U()
  where
    add-parent(S', p) --> _;
    add-parents(S', parents) --> _
  
  S |- add-parent(S', LInherit(e, alias-map, exclude-map)) --> U()
  where
    EB B(S) |- e --> RefV(S);
    read(S') --> Obj(O, parents, slots, methods);
    update(S', Obj(O, [(S, alias-map, exclude-map) | parents], slots, methods)) --> _
  
  EB B(S) |- MCallRecvL(e, ID(x), es) --> v
  where
    EB E() |- e --> recv;
    EB E() |- es --> vs;
    EB B(S) |- call-qualified(recv, x, vs) --> v
  
  add-slots(_, []) --> U()
  
  add-slots(S', [s | ss]) --> U()
  where
    default-value() --> v;
    read(S') --> Obj(O, parents, slots, methods);
    update(S', Obj(O, parents, {s |--> v, slots}, methods)) --> _;
    add-slots(S', ss) --> _
  
  add-methods(_, []) --> U()
  
  add-methods(S', [ (m, decl) | ms]) --> add-methods(S', ms)
  where
    enforce-member-policy(S', m) --> _;
    DObj DObj(S') |- method-closure(decl) --> clos;
    read(S') --> Obj(O, parents, slots, methods);
    update(S', Obj(O, parents, slots, {m |--> clos, methods})) --> _


