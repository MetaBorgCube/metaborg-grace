module trans/semantics/types

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/visibility
  trans/semantics/store
  trans/semantics/objectmodel

signature

  sorts
    TypeOp

  sort aliases
    Type = List(TypeRule)

  constructors
    TypeV: List(TypeRule) -> V
    TypeV: TypeOp * V * V -> V
    Variant: TypeOp
    Intersection: TypeOp
    Subtraction: TypeOp
    Union: TypeOp

  arrows
    TypeExp --> V

    no-type() --> TypeExp
    new-type(List(TypeRule)) --> V
    type-call(V, String, List(Exp)) --> V
    get-type(V) --> V
    get-names(V) --> List(String)
    get-object-names(Addr) --> List(String)
    get-object-type(Addr) --> V
    get-type-methods(Type) --> List(String)
    methods-to-list(Methods) --> List(String)
    methods-to-type(Methods) --> Type
    
    names-to-type(List(String)) --> Type
    
    compare-types(V, V) --> Bool
    
    compare-names(List(String), List(String)) --> Bool
    
    contains-name(String, List(String)) --> Bool

rules

  AnonType(TypeBlock(trs)) --> new-type(trs).

  TypeExp(t) --> t.

  Variant(v1, v2) --> TypeV(Variant(), v1, v2).

  no-type() --> TypeID(ID("Unknown"), NoTypeArg()).

  new-type(trs) --> TypeV(trs).

  type-call(t, "match(_)", [other]) --> BoolV(compare-types(t, get-type(other))).

  get-type(v) --> v
  where
    "getting type of: " => prefix;
    case v of {
      RefV(addr) =>
        get-object-type(addr) --> v;
        "Object Ref" => type
      StringV(_) =>
        TypeV([]) => v;
        "String V" => type
      BoolV(_) =>
        TypeV([]) => v;
        "Boolean V" => type
      tv@TypeV(_) =>
        tv => v;
        "Type V" => type
      tv@TypeV(_,_,_) =>
        tv => v;
        "Type V expr" => type
      otherwise =>
        TypeV([]) => v;
        "Unknow V" => type
    };
    log(prefix ++ type) --> _.

  get-names(v) --> t
  where
    case v of {
      RefV(addr) =>
        get-object-names(addr) --> t
      StringV(_) =>
        [] => t
      BoolV(_) =>
        [] => t
      TypeV(tr) =>
        get-type-methods(tr) --> t
      otherwise =>
        [] => t;
        halt-error("Unknown V to get type for: ", str(v)) --> _
    }.

  get-object-type(addr) --> TypeV(t)
  where
    read(addr) --> Obj(_,_,_,methods);
    methods-to-type(methods) --> t.

  get-type-methods([]) --> [] : List(String).
  get-type-methods([TypeRuleL(ID(n), _, _, _) | trs]) --> [n | get-type-methods(trs)].

  methods-to-type(methods) --> trs
  where
    methods-to-list(methods) --> mls;
    names-to-type(mls) --> trs.

  names-to-type([]) --> [].
  names-to-type([s|ss]) --> [TypeRuleL(ID(s), [], [], no-type()) | names-to-type(ss)].

  methods-to-list(map) --> methodnames
  where
    allkeys(map) => methodnames.

  compare-types(TypeV(Variant(), t1, t2), t3@TypeV(_)) --> b
  where
    compare-types(t1, t3) --> res;
    case res of {
      true =>
        true => b
      otherwise =>
        compare-types(t2, t3) --> b
    };
    log("comparing type expression and type sig") --> _.

  compare-types(t1@TypeV(_), t2@TypeV(_)) -->
    compare-names(get-names(t1), get-names(t2))
  where
    log("comparing two type sigs") --> _.

  compare-names([], _) --> true.

  compare-names(t1@[_|_],[]) --> false
  where
    log("type doesn't conform because t2 doesn't contain the types: " ++ str(t1:AST)) --> _.

  compare-names([t1|t1s], t2s) --> compare-names(t1s, t2s)
  where
    contains-name(t1, t2s) --> true;
    log("comparing names") --> _.
    
  compare-names([t1|_], t2s) --> false
  where
    contains-name(t1, t2s) --> false;
    log("comparing names, t2 is missing a type that t1 has") --> _.

  contains-name(_, []) --> false.

  contains-name(s, [s' | _]) --> true
  where
    s == s'.

  contains-name(s, [s' | ss]) --> contains-name(s, ss)
  where
    s != s'.
