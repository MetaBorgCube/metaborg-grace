module trans/semantics/booleans

imports
  src-gen/ds-signatures/grace-lowered-sig
  trans/semantics/expressions
  trans/semantics/values

signature
  constructors
    BoolV : Bool -> V

  native operators
    bool_call: V * String * V -> V
    bool_call: V * String -> V

  rules

    Boolean(True()) --> BoolV(true).
    Boolean(False()) --> BoolV(false).

    resolve-and-call(l@BoolV(_), x, []) --> bool_call(l, x).
    resolve-and-call(l@BoolV(_), x, [v]) --> bool_call(l, x, v).
    
    MCallRecvL(v1@BoolV(_), ID(op), [BlockL([], _, [Expression(e2)])]) --> bool_call(v1, op, v2)
      where
        e2 --> v2@BoolV(_).

    call@MCallL(ID("while(_)do(_)"), [e1, e2]) --> call
      where
        e1 --> v1@ClosV(_,_,_,_,_, _);
        e2 --> v2@ClosV(_,_,_,_,_, _);
        resolve-and-call(v1, "apply", []) --> BoolV(true);
        resolve-and-call(v2, "apply", []) --> _.

    MCallL(ID("while(_)do(_)"), [e1, e2]) --> DoneV()
      where
        e1 --> v1@ClosV(_,_,_,_,_,_);
        resolve-and-call(v1, "apply", []) --> BoolV(false).

    MCallRecvL(BoolV(true), ID("ifTrue(_)ifFalse(_)"), [v1, v2]) --> v
      where
        resolve-and-call(v1, "apply", []) --> v.

    MCallRecvL(BoolV(false), ID("ifTrue(_)ifFalse(_)"), [v1, v2]) --> v
      where
        resolve-and-call(v2, "apply", []) --> v.

    MCallRecvL(BoolV(b), ID("ifTrue(_)"), [v1]) --> v
      where
        case b of {
          true =>
            resolve-and-call(v1, "apply", []) --> v
          otherwise =>
            DoneV() => v
        }.

    MCallRecvL(BoolV(b), ID("ifFalse(_)"), [v1]) --> v
      where
        case b of {
          true =>
            DoneV() => v
          otherwise =>
            resolve-and-call(v1, "apply", []) --> v
        }.