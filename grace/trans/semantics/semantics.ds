module semantics/trans/semantics

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig
  
  trans/semantics/values
  trans/semantics/store
  trans/semantics/lookup

signature
  
  arrows
    Program -init-> V
    Program --> V

    List(CodeSequence) --> V

    Exp --> V
    CodeSequence --> V
    Declaration --> V
    Assignment --> V
    
    
    Inherit --> Ref
    List(Exp) -ea-> List(V)
    
  constructors
    
    Call: M * List(V) --> V
    
    saveConst: String * V * Members --> Members
    saveConstants: List(String) * List(V) * Members --> Members
    
    add-member: String * List(String) * List(CodeSequence) --> Unit
    add-members: List(String) * List(List(CodeSequence)) --> Unit
    
    wrap-values: List(V) --> List(List(CodeSequence))
    
    no-super: --> Ref
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativePrint: V -> V
    
rules
  
  Expression(e) --> e.
  Declaration(e) --> e.
  Assignment(e) --> e.
  Wrapped(v) --> v.
  
  CS(i) -s-> i.
  DS(i) -s-> i.

  Number(s) --> NumV(parseNumber(s)).
  String(s) --> StringV(s).
  
  p@Program(_, _) -init-> v
    where
      CS CS(fresh), DS DS(fresh) |- p :: OHeap {}, MHeap {} --> v.
      
  Program(code, _) --> v
    where
      allocateObject(NoObject())--> r;
      CS CS(r), DS DS(r) |- code --> v.
  
  [] : List(CodeSequence) --> Done().
  
  [code | [] ] : List(CodeSequence) --> code.

  [code | codes@[_|_] ] : List(CodeSequence) --> codes
    where code --> _.
  
  MCallRecvL(receiver, name, args) --> v
    where
       receiver --> ObjectRef(r);
       DS DS(r) |- lookup(name) --> m;
       DS DS(r) |- Call(m, args) --> v.
  
  MCallL("base_print", [v]) --> nativePrint(v).
  
  MCallL(name, vs) --> Call(lookup(name), vs).
  
  ConstantL(name, _, v) --> Done()
    where
      add-member(name, [], [Wrapped(v)]) --> _.
  
  MethodL(name, _, params, code) --> Done()
    where
      add-member(name, params, code) --> _.
      
  ds |- ObjectDecl(inherit, [], code) --> ObjectRef(or)
    where
      allocateObject(Object(ds, inherit, {})) --> or;
      CS CS(or), DS DS(or) |- code --> _.

  Call(Method([], code, scope), []) --> v
    where
      CS CS(scope), DS DS(scope) |- code --> v.
  
  Call(Method([n | _ ], code, scope), [a | _ ]) --> v
    where
      allocateObject(Object(scope, no-super(), {})) --> call-scope;
      DS DS(call-scope) |- add-member(n, [], [Wrapped(a)]) --> _;
      CS CS(call-scope), DS DS(call-scope) |- code --> v.
  
  no-super() --> allocateObject(NoObject()).
  
  wrap-values([]) --> [] : List(List(CodeSequence)).
  
  wrap-values([v|vs]) --> [ wv | wvs ] : List(List(CodeSequence))
    where
      [Wrapped(v)] --> wv;
      wrap-values(vs) --> wvs.
  
  add-members([], []) --> Unit().
  
  add-members([n | ns], [code | codes]) --> Unit()
    where
      add-member(n, [], code) --> _;
      add-members(ns, codes) --> _.
  
  ds |- add-member(name, params, code) --> Unit()
    where
      allocateMethod(Method(params, code, ds)) --> iMethod;
      readObject(ds) --> Object(enc, sup, tbl);
      writeObject(ds, Object(enc, sup, {name |--> iMethod, tbl} )) --> _.
      
  [] : List(Exp) -ea-> [].
  
  [arg] : List(Exp) -ea-> [v]
    where
      arg --> v.
  
  [arg | more] : List(Exp) -ea-> [v | vs]
    where
      arg --> v;
      more -ea-> vs : List(V).

  Inherit(e, _, _) --> r
    where
      e --> ObjectRef(r).

  NoInherit() --> r
    where
      allocateObject(NoObject()) --> r.
