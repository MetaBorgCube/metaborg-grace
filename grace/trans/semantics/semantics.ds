module semantics/trans/semantics

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig

  trans/semantics/values
  trans/semantics/store
  trans/semantics/lookup

signature

  constructors
    // for debug purposes
    WrappedP: Phase -> V
    
  arrows
    Program -init-> V
    Program --> V

    List(Statement) --> V
    List(Statement) -selectDecls-> List(Statement)
    List(Statement) -selectStmts-> List(Statement)

    Exp         --> V
    Statement   --> V
    Declaration --> V
    Declaration --> List(M)
    Assignment  --> V

    Inherit     --> Ref

    List(Exp) -ea-> List(V)

    call        (M, List(V)) --> V
    
    addMember   (String, List(String), List(Statement))         --> Unit
    addMembers  (List(String)        , List(List(Statement)))   --> Unit
    createLocals(List(String)        , List(List(Statement)))   --> Unit
    wrapValues  (List(V))                                       --> List(List(Statement))

  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativePrint: V -> V
    nativeEq: V * V -> Bool
    nativeMinus: V * V -> Int
    nativePlus: V * V -> Int
    nativeLte: V * V -> Bool

rules

  Expression(e) --> e.
  Declaration(e) --> e.
  Assignment(e) --> e.
  Code(v) --> v.

  NumL(s) --> NumV(parseNumber(s)).
  String(s) --> StringV(s).

  p@Program(_, _) -init-> v
    where
      C ObjectC(), S fresh, P Exec() |- p :: OH {}, MH {}, L {} --> v.

  Program(code, _) --> v
    where
      allocateObject(NoObject()) --> S;
      C ObjectC(), S |- code --> v.

  /*
   * Code Execution
   */
  [] : List(Statement) --> Done().
  [code | [] ] : List(Statement) --> code.
  [code | codes@[_|_] ] : List(Statement) --> codes
    where code --> _.

  /*
   * Declaration Selection
   */
  [] : List(Statement) -selectDecls-> [].
  [d@Declaration(MethodL(_,_,_,_)) | ss] : List(Statement) -selectDecls-> [d | ss']
    where
      ss -selectDecls-> ss'.
  [d@Declaration(ConstantL(_,_,_)) | ss] : List(Statement) -selectDecls-> [d | ss']
    where
      ss -selectDecls-> ss'.
  [d@Declaration(VariableL(_,_)) | ss] : List(Statement) -selectDecls-> [d | ss']
    where
      ss -selectDecls-> ss'.
  [_ | ss] : List(Statement) -selectDecls-> ss'
    where
      ss -selectDecls-> ss'.

  /*
   * Statement Selection
   */
  [] : List(Statement) -selectStmts-> [].
  [s@Assignment(AssignmentL(_,_)) | ss] : List(Statement) -selectStmts-> [s | ss']
    where
      ss -selectStmts-> ss'.
  [s@Expression(_) | ss] : List(Statement) -selectStmts-> [s | ss']
    where
      ss -selectStmts-> ss'.
  [_ | ss] : List(Statement) -selectStmts-> ss'
    where
      ss -selectStmts-> ss'.

  /*
   * Method Calls
   */
  MCallRecvL(receiver, name, args) --> v
    where
       receiver --> ObjectRef(S);
       S |- lookup(name) --> m;
       S |- call(m, args) --> v.

  /*
   * Implicit method calls (calls on self or outer)
   */
  S, P p |- MCallL("print", [v]) --> nativePrint(v)
    where
      debug("printing from self: ") => _;
      print(NumV(S)) => _;
      print(WrappedP(p)) => _.

  MCallL(name, vs) --> v
    where
      debug("generic implicit call of: '", name, "'") => _;
      lookup(name) --> m;
      call(m, vs) --> v;
      debug("done generic implicit call of: '", name, "'") => _.

  /*
   * Constants
   */
  C MethodC() |- ConstantL(name, _, e) :: L --> Done()
    where
      debug("adding local: ", name) => _;
      case L[name?] of {
        true =>
          error("Cannot rebind to constant") => _;
          error("Cannot rebind to constant: '", name, "' ") => _
        otherwise =>
          e --> v; // dynsem bug: no coersion in case switch
          writeLocal(name, v) --> _       
      }.

  C ObjectC() |- ConstantL(name, _, e) --> Done()
    where
      debug("adding member: ", name) => _;
      addMember(name, [], [Code(e)]) --> _.

  P Build() |- ConstantL(name, _, _) --> Done()
    where
      debug("__BUILD__adding member: ", name) => _;
      addMember(name, [], [Code(Uninitialized())]) --> _.

  P Init() |- ConstantL(name, _, e) --> Done()
    where
      debug("__INIT__ adding member: ", name) => _;
      addMember(name, [], [Code(e)]) --> _.


  ConstantL(_, _, _) --> Error()
    where
      error("Error: unknown context for constant") => _.

  /*
   * Variables
   */
  C MethodC() |- VariableL(name, _) --> Done()
    where
      writeLocal(name, Uninitialized()) --> _.

  C MethodC() |- AssignmentL(name, e) --> Done()
    where
      writeLocal(name, e) --> _.

  VariableL(_, _) --> Error()
    where
      error("Variables outside methods not implemented") => _.

  AssignmentL(_, _) --> Error()
    where
      error("Assignment outside methods not implemented") => _.

  /*
   * Methods
   */
  C ObjectC() |- MethodL(name, _, params, code) --> Done()
    where
      addMember(name, params, code) --> _.

  C MethodC() |- MethodL(name, _, _, _) --> Error()
    where
      error("Error: cannot create method: '", name, "' inside a methodContext") => _.

  /*
   * Object Constructors
   */
  S, P Exec() |- ObjectL(NoInherit(), [], code) --> ObjectRef(newSelf)
    where
      // allocate new object       
      allocateObject(Object(S, {})) --> newSelf; // current self becomes outer

      // build phase
      code -selectDecls-> decls;
      C ObjectC(), S newSelf, P Build() |- decls --> _; 

      // init phase
      code -selectStmts-> stmts;
      C ObjectC(), S newSelf, P Exec() |- stmts --> _.

  S, P Exec() |- ObjectL(inherit, [], code) --> ObjectRef(newSelf)
    where
      // allocate new object
      allocateObject(Object(S, {})) --> newSelf; // current self becomes outer

      // build phase
      code -selectDecls-> decls;
      C ObjectC(), S newSelf, P Build() |- decls --> _; 
      
      // build & initialize parents
      case inherit of {
        NoInherit() => 
          
        i@Inherit(_,_,_) => 
          S newSelf, P Build() |- i --> _;
          S newSelf, P Init() |- i --> _
      };
      
      // init phase
      code -selectStmts-> stmts;
      C ObjectC(), S newSelf, P Exec() |- stmts --> _.
  
  // we are currently building, now coming across an inherit expression
  S, P Build() |- ObjectL(NoInherit(), [], code) --> ObjectRef(S)
    where
            debug("object constructor in build mode, NoInherit") => _;
      code -selectDecls-> decls;
      C ObjectC(), P Build() |- decls --> _. // just build decls, nothing else
  
  S, P Build() |- ObjectL(inherit, [], code) --> ObjectRef(S)
    where
            debug("object constructor in build mode, Inherit") => _;
      inherit --> _; // eval inherit expr (still build context)
      code -selectDecls-> decls;
      C ObjectC(), P Build() |- decls --> _. // build decls
  
  S, P Init() |- ObjectL(NoInherit(), [], code) --> ObjectRef(S)
    where
            debug("object constructor in init mode, NoInherit") => _;
      code -selectStmts-> stmts;
      C ObjectC(), P Exec() |- stmts --> _. // do as normal
  
  S, P Init() |- ObjectL(inherit, [], code) --> ObjectRef(S)
    where
            debug("object constructor in init mode, Inherit") => _;
      inherit --> _; // eval inherit expr (still init context)
      code -selectStmts-> stmts; // rest of the statements
      C ObjectC(), P Exec() |- stmts --> _. // do as normal

  ObjectL(_, _, _) --> ObjectRef(allocateObject(NoObject()))
    where
      error("No valid object constructor.") => _.

  /*
   * Inherit expressions
   */
  Inherit(e, _, _) --> r
    where
      e --> ObjectRef(r).

  NoInherit() --> r
    where
      allocateObject(NoObject()) --> r.  

  /*
   * Self expression
   */ 
  S |- Self() --> ObjectRef(S).

  /*
   * Outer expression
   */
  S |- Outer() --> ObjectRef(outer) 
    where
      readObject(S) --> Object(outer, _).

  Ellipsis() --> Error()
    where
      error("Attempt to evaluate ellipsis (...)") => _.

  TraitL(name, _, body) --> ms : List(M)
    where
      [] => ms.
  

  /*
   * call (meta-function).
   */
  call(NoMethod(name), _) --> Error() // should raise exception
    where
      error("Message not understood: '", name, "'") => _.

  call(Method([], code, scope), []) :: L --> v :: L // executing a call doesnt change locals
    where
      debug("calling method with no args") => _;
      S scope, C MethodC() |- code :: L {} --> v. // scope? // always call with empty locals

  call(Method(names@[_ | _], code, scope), args@[_ | _]) :: L --> v :: L // calling has no net effect on locals
    where
      debug("calling method with some args") => _;
      createLocals(names, wrapValues(args)) :: L {} --> _ :: L1; // scope?
      S scope, C MethodC() |- code :: L1 --> v;
      debug("done calling methods with some args") => _.

  /*
   * Re-wrap values into executable code (meta-function).
   */ 
  wrapValues([]) --> [] : List(List(Statement)).

  wrapValues([v|vs]) --> [ wv | wvs ] : List(List(Statement))
    where
      [Code(v)] : List(Statement) => wv;
      wrapValues(vs) --> wvs.

  /*
   * Add members (meta-function)
   */
  addMembers([], []) --> Unit().

  addMembers([n | ns], [code | codes]) --> Unit()
    where
      addMember(n, [], code) --> _;
      addMembers(ns, codes) --> _.

  S |- addMember(name, params, code) --> Unit()
    where
      debug("attempt to write member: '", name, "'") => _;
      allocateMethod(Method(params, code, S)) --> mRef;
      readObject(S) --> Object(enc, tbl);
      writeObject(S, Object(enc, {name |--> mRef, tbl} )) --> _;
      debug("added member: '", name, "' successfully") => _;
      print(NumV(S)) => _.

  /*
   * Add locals (meta-function)
   */
  createLocals([n|ns], [code|codes]) --> Unit()
    where
      writeLocal(n, code) --> _;
      createLocals(ns, codes) --> _.

  createLocals([], []) --> Unit().

  /*
   * Evaluate arguments (meta-function)
   */
  [] : List(Exp) -ea-> [].
  [a] : List(Exp) -ea-> [v] : List(V)
    where
      a --> v.
  [a | as] : List(Exp) -ea-> [v | vs]
    where
      a --> v;
      as -ea-> vs : List(V).
