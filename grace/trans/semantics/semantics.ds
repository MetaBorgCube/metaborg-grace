module semantics/trans/semantics

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig
  
  trans/semantics/values
  trans/semantics/store
  trans/semantics/lookup

signature
  
  arrows
    Program -init-> V
    Program --> V

    List(Statement) --> V

    Exp --> V
    Statement --> V
    Declaration --> V
    Assignment --> V
    
    Inherit --> Ref
    
    List(Exp) -ea-> List(V)
    
  constructors
    
    call: M * List(V) --> V
    
    saveConst: String * V * Members --> Members
    saveConstants: List(String) * List(V) * Members --> Members

    addMember: String * List(String) * List(Statement) --> Unit
    addMembers: List(String) * List(List(Statement)) --> Unit
    
    wrapValues: List(V) --> List(List(Statement))
    
    noSuper: --> Ref
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativePrint: V -> V
    nativeEq: V * V -> Bool
    nativeMinus: V * V -> Int
    nativePlus: V * V -> Int
    nativeLte: V * V -> Bool
    
rules
  
  Expression(e) --> e.
  Declaration(e) --> e.
  Assignment(e) --> e.
  Code(v) --> v.
  
  CS(i) -s-> i.
  DS(i) -s-> i.

  NumL(s) --> NumV(parseNumber(s)).
  String(s) --> StringV(s).
  
  p@Program(_, _) -init-> v
    where
      CS CS(fresh), DS DS(fresh), C ObjectC(), S Self(fresh), Out Outer(fresh) |- p :: OHeap {}, MHeap {}, Locals {} --> v.
      
  Program(code, _) --> v
    where
      allocateObject(NoObject()) --> r;
      CS CS(r), DS DS(r), C ObjectC(), S Self(r), Out Outer(r) |- code --> v.
  
  [] : List(Statement) --> Done().
  
  [code | [] ] : List(Statement) --> code.

  [code | codes@[_|_] ] : List(Statement) --> codes
    where code --> _.
  
  
  /*
   * Method Calls
   */
  MCallRecvL(receiver, name, args) --> v
    where
       receiver --> ObjectRef(r);
       CS CS(r), DS DS(r) |- lookup(name) --> m;
       CS CS(r), DS DS(r) |- call(m, args) --> v.
  
  MCallL("base_print", [v]) --> nativePrint(v).

  MCallL(name, vs) --> v
    where
      debug("generic implicit call") => _;
      lookup(name) --> m;
      call(m, vs) --> v;
      debug("done generic implicit call") => _.
  
  /*
   * Constants
   */
  C MethodC() |- ConstantL(name, _, v) --> Done()
    where
      
      debug("adding local: ", name) => _;
      writeLocal(name, v) --> _.
  
  C ObjectC() |- ConstantL(name, _, v) --> Done()
    where
      debug("adding member: ", name) => _;
      addMember(name, [], [Code(v)]) --> _.
  
  ConstantL(_, _, _) --> Error()
    where
      debug("Error: unknown context for constant") => _.
  
  /*
   * Methods
   */
  C ObjectC() |- MethodL(name, _, params, code) --> Done()
    where
      addMember(name, params, code) --> _.

  C MethodC() |- MethodL(_, _, _, _) --> Error()
    where
      debug("Error: cannot create method inside a methodContext") => _.


  /*
   * Object Constructors
   */
  S Self(selfRef) |- ObjectL(NoInherit(), [], code) --> ObjectRef(newSelf)
    where
      fresh => objectnumber;
      debug("new obj constructor starting...") => _;
      allocateObject(NoObject()) --> noParent;
      allocateObject(Object(selfRef, noParent, {})) --> newSelf;
      S Self(newSelf), Out Outer(selfRef), C ObjectC() |- code --> _; // execute code under new self, current self becomes outer.
      debug("done constructing object") => _.  
   
  ds |- ObjectL(inherit, [], code) --> ObjectRef(or)
    where
      inherit --> r;
      allocateObject(Object(ds, r, {})) --> or;
      CS CS(or), DS DS(or), C ObjectC() |- code --> _.

  /*
   * Inherit expressions
   */
  Inherit(e, _, _) --> r
    where
      e --> ObjectRef(r).
      
  NoInherit() --> r
    where
      allocateObject(NoObject()) --> r.  

  /*
   * Self expression
   */ 
  S Self(self) |- Self() --> ObjectRef(self).

  /*
   * Outer expression
   */
  Out Outer(outer) |- Outer() --> ObjectRef(outer).

  /*
   * call (meta-function)
   */
  call(NoMethod(name), _) --> Error() // should raise exception
    where
      debug("Message not understood: ", name) => _.
  
  call(Method([], code, scope), []) --> v
    where
      debug("calling method with no args") => _;
      DS DS(scope), C MethodC() |- code :: Locals {} --> v.

  call(Method(names@[_ | _], code, scope), args@[_ | _]) --> v
    where
      debug("calling method with some args") => _;
      allocateObject(Object(scope, noSuper(), {})) --> call-scope;
      DS DS(call-scope) |- addMembers(names,wrapValues(args)) --> _;
      DS DS(call-scope), C MethodC() |- code :: Locals {} --> v.

  noSuper() --> allocateObject(NoObject()).
  
  wrapValues([]) --> [] : List(List(Statement)).
  
  wrapValues([v|vs]) --> [ wv | wvs ] : List(List(Statement))
    where
      [Code(v)] : List(Statement) => wv;
      wrapValues(vs) --> wvs.
  
  /*
   * Add members
   */
  addMembers([], []) --> Unit().
  
  addMembers([n | ns], [code | codes]) --> Unit()
    where
      addMember(n, [], code) --> _;
      addMembers(ns, codes) --> _.
  
  ds, S Self(self) |- addMember(name, params, code) --> Unit()
    where
      debug("attempt to write member: '", name, "'") => _;
      allocateMethod(Method(params, code, self)) --> mRef;
      readObject(self) --> Object(enc, sup, tbl);
      writeObject(self, Object(enc, sup, {name |--> mRef, tbl} )) --> _;
      debug("added member: '", name, "' successfully") => _.
      
  /*
   * Evaluate arguments
   */
  [] : List(Exp) -ea-> [].
  
  [a] : List(Exp) -ea-> [v] : List(V)
    where
      a --> v.
  
  [a | as] : List(Exp) -ea-> [v | vs]
    where
      a --> v;
      as -ea-> vs : List(V).
