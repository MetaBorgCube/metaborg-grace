module trans/semantics/functions

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/values
  trans/semantics/statements
  trans/semantics/objectmodel
  trans/semantics/types
  trans/semantics/booleans
  trans/semantics/visibility
  trans/semantics/controlflow
  trans/semantics/functions-errorchecking
  
signature
  sorts
    Addr
    Return-Marker
  
  constructors
    //     self   outer  params             body   env   decl. fields   public
    ClosV: Addr * Addr * List(Identifier) * Code * Env * Bool * Source * Return-Marker -> V
    
    No-Return: Return-Marker
    Return-To: Int -> Return-Marker
    
    Rex: Int * V -> Exn

  components
    R: Return-Marker
  
  arrows
    method-closure(Declaration) --> V
    block-closure(Declaration) --> V
    
  sort aliases
    Env = Map(String, Addr)
  
  components
    L : Env

  native operators
    nativePrint: V -> V

rules


  MQCallOuter(e) --> outer(S)
  where
    e --> RefV(S).

  MCallL(ID(x), es) --> v
  where
    case x of {
      "print(_)" =>
        es => [e];
        nativePrint(e) => v
        
      "while(_)do(_)" =>
        es => [e1, e2];
        while-loop(e1, e2) --> v
      
      otherwise =>
        call-implicit(x, es) --> v
    }.

  P Exec() |- MCallRecvL(e, ID(x), es) --> v
  where
    e --> recv;
    case recv of {
      BoolV(_) =>
        bool-call(recv, x, es) --> v
      NumV(_) =>
        num-call(recv, x, es) --> v
      StringV(_)=>
        str-call(recv, x, es) --> v
      otherwise =>
        call-qualified(recv, x, es) --> v
    }.

  BlockL(params, _, code) --> block-closure(MethodL(ID("lambda"), [], NoAnnotations(), params, [], no-type(), code)).

  Return(e) --> do-return(e).

signature // function return handling
  arrows
    do-return(V) --> V
    handle-return(Code, Return-Marker) --> V
  
rules

  R Return-To(r-mark) |- do-return(v) :: EX Ok() --> ??? :: EX Rex(r-mark, v).
  
  handle-return(code, No-Return()) --> v
  where
    code --> v.
  
  handle-return(code, R@Return-To(r-mark)) :: EX Ok() --> v :: EX
  where
    R |- code :: EX Ok() --> vcode :: EX1;
    case EX1 of {
      Rex(r-mark', vret) =>
        case eqI(r-mark', r-mark) of {
          true =>
            vret => v;
            Ok() => EX
          otherwise =>
            vcode => v;
            EX1 => EX
        }
      otherwise =>
        EX1 => EX;
        vcode => v
    }.

rules /* closure construction */

  Src src |- method-closure(MethodL(_, _, ann, params, _, _, code)) :: L -->
    ClosV(S, O, params, code, L', public, src, Return-To(fresh)) :: L
  where
    current-self() --> S;
    current-outer() --> O;
    alloc-locals(code) :: L --> _ :: L L';
    is-public(ann) --> public.


  block-closure(MethodL(_, _, _, params, _, _, code)) :: L --> ClosV(S, O, params, code, L', true, Bottom(), No-Return()) :: L
  where
    current-self() --> S;
    current-outer() --> O;
    alloc-locals(code) :: L --> _ :: L L'.
  

/* =========== call resolution and dispatch =========== */

signature
  arrows
    call-implicit(String, List(V)) --> V
    call-qualified(V, String, List(V)) --> V
    
    call(V, List(V), String) --> V
    
    
    resolve-and-call(V, String, List(V)) --> V



    access-local(String, List(V)) --> V
    
rules



  
  call-implicit(x, vs) --> access-local(x, vs)
  where
    is-local(x) --> true.
  
  call-implicit(x, vs) --> call(clos, vs, x)
  where
    is-local(x) --> false;
    lookup-local-method(current-self(), x) --> local-clos;
    lookup-outer-method(current-outer(), x) --> outer-clos;
    disambiguate-closure(local-clos, outer-clos, x) --> clos.



  access-local(x, [v]) --> DoneV()
  where
    str-ends-with(x, ":=(_)") --> true;
    update-local(ID(str-rm-suffix(x, ":=(_)")), v) --> _.
  
  access-local(x, []) --> read-local(x).




  call-qualified(clos@ClosV(_, _, _, _, _, _, _, _), x, vs) --> call(clos, vs, x)
  where
    str-starts-with(x, "apply") == true.
    

  call-qualified(recv, x, vs) --> call(clos, vs, x)
  where
    recv =!=> ClosV(_,_,_,_,_,_,_,_);
    lookup-local-method(recv, x) --> clos;
    disambiguate-closure(clos, x) --> _.



  call(clos@ClosV(S, O, params, code, env, _, _, R), vs, name) --> v
  where
    ensure-access(clos, S, name) --> _;
    add-locals(params, vs) :: L env --> _ :: L1;
    S, O |- handle-return(code, R) :: L1 --> v.

/* ========== local variables ============= */
signature
  arrows
    alloc-locals(Code) --> U
    Statement -alloc-> U

rules
  
  alloc-locals([]) --> U().

  alloc-locals([s | xs]) --> alloc-locals(xs)
  where
    s -alloc-> _.

  Declaration(VariableL(id, _, _, _)) -alloc-> U()
  where
    add-local(id, UninitializedV()) --> _.

  Declaration(ConstantL(id, _, _, _)) -alloc-> U()
  where
    add-local(id, UninitializedV()) --> _.

  _ : Statement -alloc-> U().

/* ======== local environment operations ========== */
signature
  arrows
    add-local(Identifier, V) --> U
    
    check-add-local(String) --> U
    
    error-add-local(Bool, Bool, Bool, String) --> U
    
    update-local(Identifier, V) --> U
    
    
    is-local(String) --> Bool
    read-local(String) --> V
    add-locals(List(Identifier), List(V)) --> U

  
    TEMP-error-add-local(V, V, String) --> U

rules

  add-local(ID(x), v) :: L --> U() :: L {x |--> addr, L}
  where
    check-add-local(x) --> _;
    v-allocate(v) --> addr.

  check-add-local(x) --> U()
  where
    lookup-local-method(current-self(), x) --> local-clos;
    lookup-outer-method(current-outer(), x) --> outer-clos;
    TEMP-error-add-local(local-clos, outer-clos, x) --> _.

  TEMP-error-add-local(v1, v2, x) --> error-add-local(self, outer, is-local(x), x)
  where
    case v1 of {
      ClosV(_, _, _, _, _, _, _, _) =>
        true => self
      otherwise =>
        false => self
    };
    case v2 of {
      ClosV(_, _, _, _, _, _, _, _) =>
        true => outer
      otherwise =>
        false => outer
    }.

  error-add-local(false,false,false, _) --> U().

  error-add-local(self,outer,local, x) --> U()
  where
    case self of {
      true => halt-error("Local '" ++ x ++ "' may not redefine method from self.", "") --> _
    };
    case outer of {
      true => halt-error("Local '" ++ x ++ "' may not shadow method from an enclosing scope.", "") --> _
    };
    case local of {
      true => halt-error("Local '" ++ x ++ "' may not redefine local method.", "") --> _
    }.




  add-local(WildCard(), _) --> U().

  update-local(ID(x), v) :: L --> U() :: L
  where
    log("updating local: '" ++ x ++ "'") --> _;
    v-update(L[x], v) --> _.
  
  update-local(WildCard(), _) --> U().

  is-local(x) :: L --> is-local :: L
  where
    ":=(_)" => bind_suffix;
    str-ends-with(x, bind_suffix) --> is-assign;
    case is-assign of {
      true =>
        str-rm-suffix(x, bind_suffix) --> x';
        L[x'?] => is-local
      false =>
        L[x?] => is-local
    }.

  read-local(x) :: L --> v-read(L[x]) :: L.  

  add-locals([], []) --> U().

  add-locals([x | xs], [v | vs]) --> add-locals(xs, vs)
  where
    log("adding locals") --> _;
    add-local(x, v) --> _.

/* ============ variable heap operations ======== */

signature
  sort aliases
    Addr = Int
    VHeap = Map(Addr, V)
  
  components
    VH : VHeap
  
  arrows
    v-allocate(V) :: H --> Addr :: H
    v-update(Addr, V) :: H --> Addr :: H
    v-read(Addr) :: H --> V :: H
    v-next() --> Addr
    
rules

  v-allocate(v) :: VH --> addr :: VH {addr |--> v, VH}
  where
    v-next() --> addr.

  v-read(addr) :: VH --> VH[addr] :: VH.

  v-update(addr, v) :: VH --> addr :: VH {addr |--> v, VH}.

  v-next() --> fresh.
