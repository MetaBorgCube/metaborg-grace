module trans/semantics/functions

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/values
  trans/semantics/statements
  trans/semantics/objectmodel
  trans/semantics/types
  trans/semantics/booleans
  trans/semantics/visibility
  
signature
  sorts
    Addr

  constructors
    //     self   outer  params             body   env   decl. fields   public
    ClosV: Addr * Addr * List(Identifier) * Code * Env * Bool * Source -> V

  arrows
    method-closure(Declaration) --> V
    
  sort aliases
    Env = Map(String, Addr)
  
  components
    L : Env

  native operators
    nativePrint: V -> V

rules

  MCallL(ID("print(_)"), [e]) --> nativePrint(v)
  where
    e --> v.

  MCallL(ID(x), vs) --> resolve-and-call-impl(x, vs)
    where
      x != "while(_)do(_)"; // TODO way to solve this more elegantly
      x != "print(_)".
  
  P Exec() |- MCallRecvL(v, ID(x), vs) --> resolve-and-call-qual(v, x, vs).

  MQCallOuter(e) --> outer(S)
  where
    e --> RefV(S).

  BlockL(params, _, code) --> method-closure(MethodL(ID("lambda"),
    [], Annotations([Public()]), params, [], no-type(), code)).

rules /* closure construction */

  Src src |- method-closure(MethodL(ID(name), _, ann, params, _, _, code)) :: L -->
    ClosV(S, O, params, code, L', public, src) :: L
  where
    current-self() --> S;
    current-outer() --> O;
    alloc-locals(code) :: L --> _ :: L L';
    log("constructing method: '" ++ name ++ "', L: " ++ str(L:AST) ++ ", L': " ++ str(L':AST)) --> _;
    is-public(ann) --> public.

/* =========== call resolution and dispatch =========== */

signature
  arrows
    resolve-and-call-impl(String, List(V)) --> V
    resolve-and-call-local(String, List(V)) --> V
    resolve-and-call-qual(V, String, List(V)) --> V
    check-method-found(Bool, String) --> U
    check-method-found(Bool, Bool, String, V) --> U
    call(V, List(V), String) --> V

rules
  
  S |- resolve-and-call-impl(x, vs) --> v
  where
    is-local(x) --> is-local;
    case is-local of {
      true =>
        resolve-and-call-local(x, vs) --> v
      false =>
        log("is '" ++ x ++ "' a member of: '" ++ int2string(S) ++ "'?") --> _;
        is-member(x) --> is-member;
        case is-member of {
          true =>
            log("is-member true, fetching method from self") --> _;
            lookup-method(current-self(), x) --> (clos, found-self);
            lookup-method(current-outer(), x) --> (_, found-outer);
            check-method-found(found-self, found-outer, x, clos) --> _
          false =>
            log("is-member false, fetching method from outer") --> _;
            lookup-method(current-outer(), x) --> (clos, f);
            check-method-found(f, x) --> _
        };
        call(clos, vs, x) --> v
    }.

  check-method-found(true, true, x, clos) --> U()
    where
      clos => ClosV(_,_,_,_,_,_,src);
      src != Bottom();
      halt-error("Method '" ++ x ++ "' is defined both as an inherited/used" ++
        "field and in an enclosing scope.", "") --> _.
  check-method-found(s, _, x, _) --> check-method-found(s, x).
  
  check-method-found(true, _) --> U().
  check-method-found(false, x) --> U()
    where
      halt-error("No such method: ", x) --> _.

  resolve-and-call-local(x, [v]) --> DoneV()
  where
    ":=(_)" => bind_suffix;
    str-ends-with(x, bind_suffix) --> true;
    update-local(ID(str-rm-suffix(x, bind_suffix)), v) --> _.
  
  resolve-and-call-local(x, []) --> read-local(x).

  resolve-and-call-qual(clos@ClosV(_, _, _, _, _, _, _), x, vs) --> call(clos, vs, x)
  where
    str-starts-with(x, "apply") == true.
  
  resolve-and-call-qual(recv, x, vs) --> call(clos, vs, x)
  where
    recv =!=> ClosV(_, _, _, _, _, _, _);
    log("resolve-and-call-qual, not a ClosV!") --> _;
    lookup-method (recv, x) --> (clos, f);
    check-method-found(f, x) --> _.

  call(ClosV(S, O, params, code, env, public, src), vs, name) --> v
  where
    check-visibility(public, S, name) --> true;
    add-locals(params, vs) :: L env --> _ :: L;
    S, O |- code :: L --> v :: L _.

  S |- call(ClosV(S', _, _, _, _, public, _), _, name) :: H --> DoneV()
  where
    check-visibility(public, S', name) --> false;
    halt-error("Requested confidential method '" ++ name ++
      "' of object: " ++ int2string(S') ++ " from outside (: " ++ int2string(S) ++
      "), Heap: ", str(H : AST)) --> _.

/* ========== local variables ============= */
signature
  arrows
    alloc-locals(Code) --> U
    Statement -alloc-> U

rules
  
  alloc-locals([]) --> U().
  
  alloc-locals([s | xs]) --> alloc-locals(xs)
  where
    s -alloc-> _.
  
  Declaration(VariableL(id, _, _, _)) -alloc-> U()
  where
    add-local(id, UninitializedV()) --> _.
  
  Declaration(ConstantL(id, _, _, _)) -alloc-> U()
  where
    add-local(id, UninitializedV()) --> _.
  
  _ : Statement -alloc-> U().

/* ======== local environment operations ========== */
signature
  arrows
    add-local(Identifier, V) --> U
    check-add-local(String) --> U
    error-add-local(Bool, Bool, Bool, String) --> U
    update-local(Identifier, V) --> U
    is-local(String) --> Bool
    read-local(String) --> V
    add-locals(List(Identifier), List(V)) --> U

rules

  add-local(ID(x), v) :: L --> U() :: L {x |--> addr, L}
  where
    log("adding local: '" ++ x ++ "'.") --> _;
    check-add-local(x) --> _;
    v-allocate(v) --> addr.
    
  check-add-local(x) --> U()
    where
      lookup-method(current-self(), x) --> (_, self);
      lookup-method(current-outer(), x) --> (_, outer);
      is-local(x) --> local;
      error-add-local(self,outer,local,x) --> _.
  
  error-add-local(false,false,false, _) --> U().
  error-add-local(self,outer,local, x) --> U()
    where
      case self of {
        true => halt-error("Local '" ++ x ++ "' may not redefine method from self.", "") --> _
      };
      case outer of {
        true => halt-error("Local '" ++ x ++ "' may not shadow method from an enclosing scope.", "") --> _
      };
      case local of {
        true => halt-error("Local '" ++ x ++ "' may not redefine local method.", "") --> _
      }.
  
  add-local(WildCard(), _) --> U().
  
  update-local(ID(x), v) :: L --> U() :: L
  where
    log("updating local: '" ++ x ++ "'") --> _;
    v-update(L[x], v) --> _.
  
  update-local(WildCard(), _) --> U().

  is-local(x) :: L --> is-local :: L
  where
    ":=(_)" => bind_suffix;
    str-ends-with(x, bind_suffix) --> is-assign;
    case is-assign of {
      true =>
        str-rm-suffix(x, bind_suffix) --> x';
        L[x'?] => is-local
      false =>
        L[x?] => is-local
    }.
  
  read-local(x) :: L --> v-read(L[x]) :: L.  

  add-locals([], []) --> U().

  add-locals([x | xs], [v | vs]) --> add-locals(xs, vs)
  where
    log("adding locals") --> _;
    add-local(x, v) --> _.
  
/* ============ variable heap operations ======== */

signature
  sort aliases
    Addr = Int
    VHeap = Map(Addr, V)
  
  components
    VH : VHeap
  
  arrows
    v-allocate(V) :: H --> Addr :: H
    v-update(Addr, V) :: H --> Addr :: H
    v-read(Addr) :: H --> V :: H
    v-next() --> Addr
    
rules

  v-allocate(v) :: VH --> addr :: VH {addr |--> v, VH}
  where
    v-next() --> addr.
  
  v-read(addr) :: VH --> VH[addr] :: VH.

  v-update(addr, v) :: VH --> addr :: VH {addr |--> v, VH}.
  
  v-next() --> fresh.
  