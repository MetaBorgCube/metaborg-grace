module trans/semantics/functions/func-locals-policy

imports
  semantics/signatures
  trans/semantics/values
  trans/semantics/functions/func-locals
  trans/semantics/objects/path
  trans/semantics/objects/method-resolution

signature
  sorts
    TMP___ // workaround for dynsem bug causing tuple constructor to not be generated
  constructors
    TMP___ : (Bool * Bool) -> TMP___
    
  arrows
    policy-locals-allow-duplicates() --> Bool
    policy-locals-allow-shadow-local() --> Bool
    policy-locals-allow-shadow-member() --> Bool
    policy-locals-allow-shadow-inherited() --> Bool
  
    enforce-closure-policy(Loc) --> U
    enforce-closure-policy-aux(Loc, List(V)) --> U
    enforce-closure-policy(Loc, V) --> U
    enforce-closure-policy-aux(List(Identifier)) --> U
    enforce-block-policy(Closure) --> U
    check-locals-duplicates(List(Identifier)) --> U
    check-locals-duplicates-aux(List(Identifier)) --> Map(Identifier, Identifier)
    check-local-shadow-local(Identifier) --> U
    check-local-shadow-member(Identifier) --> U
    check-local-shadow-inherited(Identifier) --> U
    
//    idents-to-strings(List(Identifier)) --> List(String)

rules
  
  policy-locals-allow-duplicates() --> false
  policy-locals-allow-shadow-local() --> false
  policy-locals-allow-shadow-member() --> false
  policy-locals-allow-shadow-inherited() --> true
  
  
rules
  
  enforce-closure-policy(S) --> U()
  where
    read(S) --> Obj(_, _, attrs);
    enforce-closure-policy-aux(S, allvalues(attrs)) --> _
  
  enforce-closure-policy-aux(_, []) --> U()
  
  enforce-closure-policy-aux(S, [ v | closs]) --> enforce-closure-policy-aux(S, closs)
  where
    v =!=> ClosVis(_, _)
  
  enforce-closure-policy-aux(S, [clos@ClosVis(_, _) | closs]) --> enforce-closure-policy-aux(S, closs)
  where
    enforce-closure-policy(S, clos) --> _
  
  enforce-closure-policy(S, ClosVis(Clos(_, O, params, locals, _, _), _)) --> U()
  where
    params ++ locals => vars;
    check-locals-duplicates(vars) --> _;
    S, O |- enforce-closure-policy-aux(vars) --> _

  enforce-block-policy(Block(S, clos)) --> enforce-closure-policy(S, ClosVis(clos, Pub()))

  check-locals-duplicates(xs) --> U()
  where
    case policy-locals-allow-duplicates() : Bool of {
      true =>
      false =>
        check-locals-duplicates-aux(`xs) --> _
    }

  check-locals-duplicates-aux([]) --> {}
  
  check-locals-duplicates-aux([x | xs]) --> {x |--> x, x-map}
  where
    check-locals-duplicates-aux(xs) --> x-map;
    case x-map[x?] of {
      true =>
        name(x) --> name;
        halt-error("Duplicate local variable '" ++ name ++ "'") --> _
      false =>
    }

  enforce-closure-policy-aux([]) --> U()
  
  enforce-closure-policy-aux([x | xs]) --> U()
  where
    check-local-shadow-local(x) --> _;
    check-local-shadow-member(x) --> _;
    check-local-shadow-inherited(x) --> _;
    enforce-closure-policy-aux(xs) --> _

  check-local-shadow-local(x) --> U()
  where
    case policy-locals-allow-shadow-local() : Bool of {
      true =>
      false =>
        case is-local(x) : Bool of {
          true =>
            name(x) --> name;
            halt-error("Variable '" ++ name ++ "' is already declared in an enclosing method") --> _
          false =>
        }
    }
  
  S, O |- check-local-shadow-member(x) --> U()
  where
    case policy-locals-allow-shadow-member() : Bool of {
      true =>
      false =>
        S, O |- resolve(x, S) --> path;
        case path-found(path) : Bool of {
          true =>
            case path-local(path) : Bool of {
              true =>
                name(x) --> name;
                halt-error("Variable '" ++ name ++ "' shadows member in surrounding object") --> _
              false =>
            };
            case path-strictly-lexical(path) : Bool of {
              true =>
                name(x) --> name;
                halt-error("Variable '" ++ name ++ "' shadows member in enclosing scope") --> _
              false =>
            }
          false =>
        }
    }
  
  S, O |- check-local-shadow-inherited(x) --> U()
  where
    case policy-locals-allow-shadow-inherited() : Bool of {
      true =>
      false =>
        S, O |- resolve(x, S) --> path;
        case path-found(path) : Bool of {
          true =>
            case path-strictly-inherited(path) : Bool of {
              true =>
                name(x) --> name;
                halt-error("Variable '" ++ name ++ "' shadows inherited member") --> _
              false =>
            };
            case (path-lexical(path) : Bool, path-strictly-lexical(path) : Bool) of {
              (true, false) =>
                name(x) --> name;
                halt-error("Variable '" ++ name ++ "' shadows member inherited into a surrounding scope") --> _
              otherwise =>
            }
          false =>
        }
    }
    

