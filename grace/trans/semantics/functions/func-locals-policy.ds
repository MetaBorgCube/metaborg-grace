module trans/semantics/functions/func-locals-policy

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/values
  trans/semantics/functions/func-locals
  trans/semantics/objects/path
  trans/semantics/objects/method-resolution

signature
  arrows
    policy-member-applies-to(String) --> Bool
  
    policy-members-allow-duplicates() --> Bool
    policy-members-allow-duplicate-inherited() --> Bool
    policy-members-allow-shadow-lexical-local() --> Bool
    policy-members-allow-shadow-lexical-member() --> Bool
    policy-members-allow-shadow-lexical-inherited() --> Bool


    enforce-member-policy(Addr, String) --> U
    check-member-duplicate(String, Path) --> U
    check-member-duplicate-inherited(String, Path) --> U
    check-members-shadow-lexical-local(String, Path) --> U
    check-members-shadow-lexical-member(String, Path) --> U
    check-members-shadow-lexical-inherited(String, Path) --> U
    
rules
  
  policy-members-allow-duplicates() --> false
  policy-members-allow-duplicate-inherited() --> true
  policy-members-allow-shadow-lexical-local() --> false
  policy-members-allow-shadow-lexical-member() --> true
  policy-members-allow-shadow-lexical-inherited() --> true
  
rules
  
  policy-member-applies-to(x) --> notB(str-starts-with(x, "#"))
  
  enforce-member-policy(S, x) --> U()
  where
    case policy-member-applies-to(x) : Bool of {
      false =>
      true =>
        outer-addr(S) --> O;
        S, O |- resolve(x, S) --> x-path;
        case path-found(x-path) : Bool of {
          false =>
          otherwise =>
            check-member-duplicate(x, x-path) --> _;
            check-member-duplicate-inherited(x, x-path) --> _;
            check-members-shadow-lexical-local(x, x-path) --> _;
            check-members-shadow-lexical-member(x, x-path) --> _;
            check-members-shadow-lexical-inherited(x, x-path) --> _
      }
    }
  
  check-member-duplicate(x, path) --> U()
  where
    case policy-members-allow-duplicates() : Bool of {
      true =>
      false =>
        case path-local(path) : Bool of {
          true =>
            halt-error("Duplicate member '" ++ x ++ "'") --> _
          false =>
            case path-local-aliased(x, path) : Bool of {
              true =>
                halt-error("Duplicate member '" ++ x ++ "'") --> _
              false =>
            }
        }
    }
  
  check-member-duplicate-inherited(x, path) --> U()
  where
    case policy-members-allow-duplicate-inherited() : Bool of {
      true =>
      false =>
        case path-strictly-inherited(path) : Bool of {
          true =>
            halt-error("Member '" ++ x ++ "' overrides inherited member") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-local(x, _) --> U()
  where
    case policy-members-allow-shadow-lexical-local() : Bool of {
      true =>
      false =>
        case is-local(x) : Bool of {
          true =>
            halt-error("Member '" ++ x ++ "' shadows local variable in surrounding scope") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-member(x, x-path) --> U()
  where
    case policy-members-allow-shadow-lexical-member() : Bool of {
      true =>
      false =>
        case path-strictly-lexical(x-path) : Bool of {
          true =>
            halt-error("Member '" ++ x ++ "' shadows member defined in surrounding scope") --> _
          false =>
        }
    }
  
  check-members-shadow-lexical-inherited(x, x-path) --> U()
  where
    case policy-members-allow-shadow-lexical-inherited() : Bool of {
      true =>
      false =>
        case (path-lexical(x-path) : Bool, path-strictly-lexical(x-path) : Bool) of {
          (true, false) =>
            halt-error("Member '" ++ x ++ "' shadows member inherited into surrounding scope") --> _
          otherwise =>
        }
    }

signature
  sorts
    TMP___ // workaround for dynsem bug causing tuple constructor to not be generated
  constructors
    TMP___ : (Bool * Bool) -> TMP___
    
  arrows
    policy-locals-allow-duplicates() --> Bool
    policy-locals-allow-shadow-local() --> Bool
    policy-locals-allow-shadow-member() --> Bool
    policy-locals-allow-shadow-inherited() --> Bool
  
    enforce-closure-policy(Addr) --> U
    enforce-closure-policy-aux(Addr, List(AnnotatedClosure)) --> U
    enforce-closure-policy(Addr, AnnotatedClosure) --> U
    enforce-closure-policy-aux(List(String)) --> U
    enforce-block-policy(Closure) --> U
    check-locals-duplicates(List(String)) --> U
    check-locals-duplicates-aux(List(String)) --> Map(String, String)
    check-local-shadow-local(String) --> U
    check-local-shadow-member(String) --> U
    check-local-shadow-inherited(String) --> U
    
    idents-to-strings(List(Identifier)) --> List(String)

rules
  
  policy-locals-allow-duplicates() --> false
  policy-locals-allow-shadow-local() --> false
  policy-locals-allow-shadow-member() --> false
  policy-locals-allow-shadow-inherited() --> true
  
  
rules
  
  enforce-closure-policy(S) --> U()
  where
    read(S) --> Obj(_, _, _, methods);
    enforce-closure-policy-aux(S, allvalues(methods)) --> _
  
  enforce-closure-policy-aux(_, []) --> U()
  
  enforce-closure-policy-aux(S, [clos | closs]) --> enforce-closure-policy-aux(S, closs)
  where
    enforce-closure-policy(S, clos) --> _
  
  enforce-closure-policy(S, ClosVis(Clos(O, params, locals, _, _), _)) --> U()
  where
    idents-to-strings(params ++ locals) --> xs;
    check-locals-duplicates(xs) --> _;
    S, O |- enforce-closure-policy-aux(xs) --> _

  enforce-block-policy(Block(S, clos)) --> enforce-closure-policy(S, ClosVis(clos, Pub()))

  check-locals-duplicates(xs) --> U()
  where
    case policy-locals-allow-duplicates() : Bool of {
      true =>
      false =>
        check-locals-duplicates-aux(`xs) --> _
    }

  check-locals-duplicates-aux([]) --> {}
  
  check-locals-duplicates-aux([x | xs]) --> {x |--> x, x-map}
  where
    check-locals-duplicates-aux(xs) --> x-map;
    case x-map[x?] of {
      true =>
        halt-error("Duplicate local variable '" ++ x ++ "'") --> _
      false =>
    }

  enforce-closure-policy-aux([]) --> U()
  
  enforce-closure-policy-aux([x | xs]) --> U()
  where
    check-local-shadow-local(x) --> _;
    check-local-shadow-member(x) --> _;
    check-local-shadow-inherited(x) --> _;
    enforce-closure-policy-aux(xs) --> _

  check-local-shadow-local(x) --> U()
  where
    case policy-locals-allow-shadow-local() : Bool of {
      true =>
      false =>
        case is-local(x) : Bool of {
          true =>
            halt-error("Variable '" ++ x ++ "' is already declared in an enclosing method") --> _
          false =>
        }
    }
  
  S, O |- check-local-shadow-member(x) --> U()
  where
    case policy-locals-allow-shadow-member() : Bool of {
      true =>
      false =>
        S, O |- resolve(x, S) --> path;
        case path-found(path) : Bool of {
          true =>
            case path-local(path) : Bool of {
              true =>
                halt-error("Variable '" ++ x ++ "' shadows member in surrounding object") --> _
              false =>
            };
            case path-strictly-lexical(path) : Bool of {
              true =>
                halt-error("Variable '" ++ x ++ "' shadows member in enclosing scope") --> _
              false =>
            }
          false =>
        }
    }
  
  S, O |- check-local-shadow-inherited(x) --> U()
  where
    case policy-locals-allow-shadow-inherited() : Bool of {
      true =>
      false =>
        S, O |- resolve(x, S) --> path;
        case path-found(path) : Bool of {
          true =>
            case path-strictly-inherited(path) : Bool of {
              true =>
                halt-error("Variable '" ++ x ++ "' shadows inherited member") --> _
              false =>
            };
            case (path-lexical(path) : Bool, path-strictly-lexical(path) : Bool) of {
              (true, false) =>
                halt-error("Variable '" ++ x ++ "' shadows member inherited into a surrounding scope") --> _
              otherwise =>
            }
          false =>
        }
    }
    

  idents-to-strings([]) --> []
  
  idents-to-strings([WildCard() | xs]) --> idents-to-strings(xs)
  
  idents-to-strings([ID(x) | xs]) --> [x | xs']
  where
    idents-to-strings(xs) --> xs'
