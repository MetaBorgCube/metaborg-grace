module trans/semantics/functions/func-call

imports
  trans/semantics/expressions
  trans/semantics/statements
  trans/semantics/functions/func-repr
  trans/semantics/objects/method-resolution
  trans/semantics/objects/lookup
  
signature
  arrows
    call-unqualified(Identifier, List(V)) --> V
    call-qualified(V, Identifier, List(V)) --> V
    
    call(Closure, List(V)) --> V
    RCode --> V
    doreturn(V) --> V
    catch-return(Code, ReturnMarker) --> V
    
  constructors
    RExn: Int * V -> Exn
  
  components
    R: ReturnMarker
  
rules

  call-unqualified(x, vs) --> call-qualified(DoneV(), x, vs)
  where
    is-local(x) --> true
  
  S |- call-unqualified(x, vs) --> v
  where
    is-local(x) --> false;
    resolve-lookup(x, S) --> (S', clos);
    S' |- call(clos, vs) --> v  

  // object as receiver
  call-qualified(RefV(S), x, vs) --> v
  where
    O bogus-addr(), S |- resolve-lookup(x, S) --> (_, clos);
    S |- call(clos, vs) --> v

  // block as receiver of apply method  
  call-qualified(BlockV(clos), x, vs) --> v
  where
    str-starts-with(name(x), "apply") --> true;
    call(clos, vs) --> v
  
  // block as receiver of asString method
  call-qualified(BlockV(_), x, []) --> StringV("block<SOMELOCATION>")
  where
    name(x) --> "asString"
  
  // local variable read 
  call-qualified(DoneV(), x, []) --> read-local(x)
  
  // local variable assign
  call-qualified(DoneV(), x, [v]) --> DoneV()
  where
    name(x) --> name;
    str-ends-with(name, ":=(_)") --> true;
    write-local(mk-identifier(str-rm-suffix(name, ":=(_)")), v) --> _

  call(Block(S, clos), vs) --> v
  where
    S |- call(clos, vs) --> v
  
  call(Clos(DObj, O, params, locals, rcode, E_func), vs) :: E --> v :: E
  where
    bind-locals(locals) :: E_func --> _ :: E_func';
    bind-locals(params, vs) :: E_func' --> _ :: E_func'';
    DObj, O |- rcode :: E_func'' --> v
  
  RCode(code, DynRet()) --> v
  where
    R(fresh) => R;
    R |- catch-return(code, R) --> v
  
  R |- RCode(code, StatRet(R')) --> v
  where
    R' |- catch-return(code, R) --> v
  
  catch-return(code, R(r-to)) :: EX Ok() --> v :: EX
  where
    code :: EX Ok() --> vcode :: EX_code;
    case EX_code of {
      RExn(r-to', vret) =>
        case eqI(r-to', r-to) of {
          true =>
            Ok() => EX;
            vret => v
          otherwise =>
            EX_code => EX;
            vcode => v
        }
      otherwise =>
        EX_code => EX;
        vcode => v
    }
  
  R R(r-to) |- doreturn(v) :: EX Ok() --> ??? :: EX RExn(r-to, v)

