module trans/semantics/functions/functions

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/values
  trans/semantics/functions/func-desugar
  trans/semantics/functions/func-call
  trans/semantics/functions/visibility
  trans/semantics/functions/func-locals-policy
  trans/semantics/types
  trans/semantics/objects/obj-constr
  
signature
    
  arrows
    method-closure(Declaration) --> AnnotatedClosure
    block-closure(Declaration) --> Closure
    
rules
  
  O |- method-closure(m@MethodL(_, _, _, _, _, _, _)) :: E --> ClosVis(clos, vis) :: E
  where
    method-desugar(m) --> LFunc(params, locals, code, vis);
    Clos(O, params, locals, RCode(code, DynRet()), E) => clos
  
  S, O, R |- block-closure(m@MethodL(_, _, _, _, _, _, _)) :: E --> Block(S, clos) :: E
  where
    method-desugar(m) --> LFunc(params, locals, code, _);
    Clos(O, params, locals, RCode(code, StatRet(R)), E) => clos
  
  BlockL(params, _, code) --> BlockV(block-closure(MethodL(ID("lambda"), [], Annotations([Public()]), params, [], no-type(), code)))

  Return(e) --> doreturn(e)




// TODO refactor below

imports
  trans/semantics/controlflow

signature
  native operators
    nativePrint: V -> V

rules

  MCallL(ID(x), es) --> v
  where
    case x of {
      "print(_)" =>
        es => [e];
        nativePrint(e) => v
        
      "while(_)do(_)" =>
        es => [e1, e2];
        while-loop(e1, e2) --> v
      
      otherwise =>
        call-unqualified(x, es) --> v
    }

  EB E() |- MCallRecvL(e, ID(x), es) --> v
  where
    e --> recv;
    case recv of {
      BoolV(_) =>
        bool-call(recv, x, es) --> v
      NumV(_) =>
        num-call(recv, x, es) --> v
      StringV(_) =>
        str-call(recv, x, es) --> v
      otherwise =>
        call-qualified(recv, x, es) --> v
    }