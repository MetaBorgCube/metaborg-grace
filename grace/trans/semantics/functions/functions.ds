module trans/semantics/functions/functions

imports
  semantics/signatures
  trans/semantics/values
  trans/semantics/functions/func-desugar
  trans/semantics/functions/func-call
  trans/semantics/functions/visibility
  trans/semantics/functions/func-locals-policy
  trans/semantics/types
  trans/semantics/objects/obj-constr
  trans/semantics/lib/lib
  
signature
    
  arrows
    method-closure(Declaration) --> V
    block-closure(Declaration) --> Closure
    
rules
  
  DObj, O |- method-closure(m@MethodLS(_, _, _, _, _, _, _, _)) :: E --> ClosVis(clos, vis) :: E
  where
    method-desugar(m) --> LFunc(params, locals, code, vis);
    Clos(DObj, O, params, locals, RCode(code, DynRet()), E) => clos
  
  S, O, R |- block-closure(m@MethodLS(_, _, _, _, _, _, _, _)) :: E --> Block(S, clos) :: E
  where
    method-desugar(m) --> LFunc(params, locals, code, _);
    Clos(DObj(S), O, params, locals, RCode(code, StatRet(R)), E) => clos

  BlockLS(params, _, locals, code) --> BlockV(clos)
  where
    block-closure(MethodLS(ID("lambda"), [], Annotations([Public()]), params, [], no-type(), locals, code)) --> clos
//    enforce-block-policy(clos) --> _

  Return(e) --> doreturn(e)

  ReturnVoid() --> doreturn(DoneV())



// TODO refactor below

imports
  trans/semantics/controlflow

signature
  native operators
    nativePrint: V -> V

  arrows
    call-qualified-proxy(V, String, List(Exp)) --> V

rules

  MCallL(ID(x), es) --> v_res
  where
    case x of {
      "print(_)" =>
        es => [e];
        nativePrint(call-qualified-proxy(e, "asString", [])) => v_res
        
      "while(_)do(_)" =>
        es => [e1, e2];
        while-loop(e1, e2) --> v_res
      
      otherwise =>
        call-unqualified(x, es) --> v_res
    }

  EB E() |- MCallRecvL(e, ID(x), es) --> call-qualified-proxy(e, x, es)
  
  call-qualified-proxy(recv, x, es) --> v
  where
    case is-native(recv) : Bool of {
      true =>
        native-call(recv, x, es) --> v
      otherwise =>
        call-qualified(recv, x, es) --> v
    }
    