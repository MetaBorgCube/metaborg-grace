module trans/semantics/functions/calls

imports
  src-gen/ds-signatures/grace-sig
  trans/semantics/statements
  trans/semantics/functions/locals
  trans/semantics/objects/object
  
signature
  sorts
    Return-Marker
  
  constructors
    ClosV: Outer * List(Identifier) * List(Identifier) * Code * Env * Bool * Return-Marker -> V
    
    No-Return: Return-Marker
    Return-To: Int -> Return-Marker
    
    Rex: Int * V -> Exn

  components
    R: Return-Marker

/* =========== call resolution and dispatch =========== */
signature
  arrows
    call-implicit(String, List(V)) --> V
    call-qualified(V, String, List(V)) --> V
    call(V, List(V)) --> V
    
    access-local(String, List(V)) --> V
    
//    disambiguate-closure(V, String) --> V
//    disambiguate-closure(V, V, String) --> V
    
rules
  
  call-implicit(x, vs) --> access-local(x, vs)
  where
    is-local(x) --> true.
  
  S |- call-implicit(x, vs) --> v
  where
    is-local(x) --> false;
      log("ICall non-local " ++ x) --> _;
    lookup(x, S) --> path;
      log("Found " ++ x ++ " at " ++ str(path : AST)) --> _;
    resolve(path, S) --> clos;
      log("Resolved to " ++ str(clos)) --> _;
    call(clos, vs) --> v;
      log("Call result " ++ str(v)) --> _.

  access-local(x, [v]) --> DoneV()
  where
    str-ends-with(x, ":=(_)") --> true;
    update-local(ID(str-rm-suffix(x, ":=(_)")), v) --> _.
  
  access-local(x, []) --> read-local(x).

  // TODO handle lambdas

//  call-qualified(clos@ClosV(_, _, _, _, _, _, _), x, vs) --> call(clos, vs, x)
//  where
//    str-starts-with(x, "apply") == true.
    
  call-qualified(RefV(S), x, vs) --> v
  where
    // TODO enforce visibility
      log("QCall non-local " ++ x) --> _;
    lookup(x, S) --> path;
      log("Found " ++ x ++ " at " ++ str(path : AST)) --> _;
    resolve(path, S) --> clos;
      log("Resolved to " ++ str(clos)) --> _;
    call(clos, vs) --> v;
      log("Call result " ++ str(v)) --> _.

  S |- call(ClosV(O, params, locals, code, L1, _, R), vs) :: L --> v :: L
  where
    // TODO enforce visibility
    add-locals(locals) :: L1 --> _ :: L2;
    update-locals(params, vs) :: L2 --> _ :: L3;
    S, O |- handle-return(code, R) :: L3 --> v :: L4.
  
//  closure-source(ClosV(_, _, _, _, _, _, _, Src, _)) --> Src.
  
signature
  arrows
    do-return(V) --> V
    handle-return(Code, Return-Marker) --> V
  
rules

  R Return-To(r-mark) |- do-return(v) :: EX Ok() --> ??? :: EX Rex(r-mark, v).
  
  handle-return(code, No-Return()) --> v
  where
    code --> v.
  
  handle-return(code, R@Return-To(r-mark)) :: EX Ok() --> v :: EX
  where
    R |- code :: EX Ok() --> vcode :: EX1;
    case EX1 of {
      Rex(r-mark', vret) =>
        (v, EX) as (vret, Ok()) if eqI(r-mark', r-mark)
                or (vcode, EX1)
      otherwise =>
        EX1 => EX;
        vcode => v
    }.

     