module trans/semantics/object/object

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/statements

signature
  sort aliases
    Self = Addr
    Outer = Addr
    
  components
    S : Self
    O : Outer
    R : Addr // root object
  
  constructors
    RefV: Addr -> V {implicit}
  
  sorts
    Object
  
  sort aliases
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)
    Aliases = Map(String, String)
    Excludes = Map(String, String)
    Parent = (Addr * Aliases * Excludes)
    Parents = List(Parent)
    IsFresh = Bool
  
  constructors
    Obj: Outer * Parents * Slots * Methods * IsFresh -> Object

  sorts
    EvalMode
  
  constructors
    E: EvalMode
    B: EvalMode

  components
    EB : EvalMode
  
  arrows
    init-object() --> U
    Inherit --> Parent
    List(Use) --> Parents
    Use --> Parent
    
    code-split(Code) --> (Slots * Methods) 
    constr-name() --> String
    
    alias-map(List(Alias)) --> Aliases
    exclude-map(List(Exclude)) --> Excludes
    
rules

  S, O, EB |- ObjectL(inherit, uses, code) --> RefV(S')
  where
    allocate(Obj(O, [], {}, {}, true)) --> S';
    S S', O S |- inherit --> super;
    S S', O S |- uses --> traits;
    code-split(code) --> (slots, methods);
    update(S', Obj(O, [super|traits], slots, methods, true)) --> _; // !!! reverse the list of parents
    case EB of {
      E() =>
        S S', O S |- init-object() --> _
    }.

  R |- NoInherit() --> (R, {}, {}).
  
  InheritL(e, aliases, excludes) --> (S, alias-map(aliases), exclude-map(excludes))
  where
    EB B() |- e --> RefV(S).
  
  [] : List(Use) --> [].
  
  [use | uses] : List(Use) --> [p | ps]
  where
    use --> p;
    uses --> ps.
  
  UseL(e, aliases, excludes) --> (S, alias-map(aliases), exclude-map(excludes))
  where
    EB B() |- e --> RefV(S).
  
//  EB B() |- MCallRecvL(e, ID(x), es) --> v
//  where
//    EB E() |- e --> recv;
//    EB E() |- es --> vs;
//    EB B() |- call-qualified(recv, x, vs) --> v.
