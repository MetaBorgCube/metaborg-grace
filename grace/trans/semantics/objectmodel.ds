module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/lineups
  trans/semantics/functions
  trans/semantics/statements
  trans/semantics/imports

signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
    Obj: Addr * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
  
rules

  S, P Exec() |- ObjectL(inherit, [], code) --> S'
  where
    new-object(S) --> S';
    S S', O S, P Flatten() |- inherit --> FlatObject(closures-inherited);
    closures-inherited ++ [Closure(S, code)] => closures;
    S' |- install-members(closures) --> closures';
    S' |- init-object(closures') --> U();
    log-object-creation(S') --> _.
  
  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.

/* ========== INIT METHODS =========== */

signature
  arrows
    install-members(Closures) --> Closures
    install-members-aux(Closures) --> Closures
    
    Closure -member-> Closure
    Code -member-> Code
    
    install-method(Declaration) --> U
    
rules

  install-members(closures) --> closures'
  where
    install-members-aux(closures) :: NS 0, GS {} --> closures' :: NS _, GS _.

  install-members-aux([]) --> [].
  
  install-members-aux([clos | closs]) --> [clos' | install-members-aux(closs)]
  where
    clos -member-> clos'.
  
  Closure(O, code) -member-> Closure(O, current-method-names(), code')
  where
    O |- code -member-> code'.
    
  [] : Code -member-> [].
  
  [Declaration(m@MethodL(_, _, _, _, _, _, _)) | cs] : Code -member-> cs'
  where
    install-method(m) --> _;
    cs -member-> cs'.
  
  [Declaration(VariableL(ID(x), _, _, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i)) --> _;
    install-method(field-setter(x, i)) --> _;
    cs -member-> cs'.

  [Declaration(VariableL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
  where
    cs -member-> cs'.
  
  [Import(name, ID(x), _) | cs] : Code -member-> cs'
    where
      add-slot(x) --> i;
      get-import-object(name) --> iAddr;
      write-slot(i, RefV(iAddr)) --> _;
      install-method(field-getter(x, i)) --> _;
      cs -member-> cs'.
  
  [Declaration(ConstantL(ID(x), _, _, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i)) --> _;
    cs -member-> cs'.
    
  [Declaration(ConstantL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
  where
    cs -member-> cs'.
  
  [c | cs] : Code -member-> [c | cs']
  where
    cs -member-> cs'.
  
  install-method(m@MethodL(ID(name), _, _, _, _, _, _)) --> U()
  where
    add-method(name, method-closure(m)) --> _.

/* ========== OBJECT INIT ======== */
signature
  arrows
    init-object(Closures) --> U
    
    Closure -obji-> U
    Code -obji-> U
    Statement -obji -> U
    
rules
  
  init-object([]) --> U().
  
  init-object([clos | closs]) --> init-object(closs)
  where
    clos -obji-> _.
  
  Closure(O, M, code) -obji-> U()
  where
    M, O |- code -obji-> _.
    
  [] : Code -obji-> U().
  
  [c | cs] : Code -obji-> U()
  where
    c -obji-> _;
    cs -obji-> _.

  s : Statement -obji-> U()
  where
    s --> _.

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int) --> Declaration
    field-setter(String, Int) --> Declaration
  
  native operators
    mksettername: String -> String
  
rules

  field-getter(x, i) --> MethodL(ID(x), [], NoAnnotations(), [], [], no-type(), [SlotRead(i)]).
  
  field-setter(x, i) --> MethodL(ID(mksettername(x)), [], NoAnnotations(), [ID("p")], [], no-type(), [SlotWrite(i, MCallL(ID("p"), [] : List(Exp)))]).

/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  components
    P : Phase
    
  sorts
    Closure
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code -> Closure
    Closure: Addr * List(String) * Code -> Closure
    FlatObject: List(Closure) -> V

  arrows
    Inherit --> V

rules

  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(closures-inherited ++ [Closure(S, code)])
  where
    O S, P Flatten() |- inherit --> FlatObject(closures-inherited).

  P Flatten() |- MCallRecvL(e, ID(x), es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-and-call(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _) --> v
  where
    e --> v@FlatObject(_).  // TODO this is where to check whether the inherit expression actually returns a fresh object

/* ======== OBJECT META-FUNCTIONS ========= */

signature
  arrows
    new-object(Addr) --> Addr

    add-slot(String) --> Int
    
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    
    lookup-method(V, String) --> V
    
    current-self() --> V
    current-outer() --> V
    current-method-names() --> List(String)
    
    outer(Addr) --> V
    self(Addr) --> V
    
  components
    NS : Int // NextSlot
    GS : Map(String, Int) // GivenSlots

rules

  S |- current-self() --> S.
  
  O |- current-outer() --> O.
  
  self(S) --> S.
  
  outer(S) --> O
  where
    read(S) --> Obj(O, _, _).
  
  new-object(O) --> S
  where
    allocate(Obj(O, {}, {})) --> S.

  add-slot(x) :: GS --> GS[x] :: GS
  where
    GS[x?] == true.
  
  S |- add-slot(x) :: NS, GS --> NS :: NS addI(NS, 1), GS {x |--> NS, GS}
  where
    GS[x?] == false;
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {NS |--> UninitializedV(), slots}, methods)) --> _.
    
  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, slots, _).
  
  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    log("S: " ++ str(S) ++ " O " ++ str(O) ++ " new method: " ++ x ++ " -> " ++ str(v)) --> _;
    update(S, Obj(O, slots, {x |--> v, methods})) --> _.
  
  S |- current-method-names() --> allkeys(methods)
  where
    read(S) --> Obj(_, _, methods).
  
  S, O |- lookup-method(S', x) --> v
  where
    S == S';
    read(S') --> Obj(O', _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        S O, O O' |- lookup-method(O, x) --> v
    }.

  S |- lookup-method(S', x) --> v
  where
    S != S';
    read(S') --> Obj(_, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        halt-error("No method: ", x) --> _;
        DoneV() => v
    }.

signature
  arrows
     log-object-creation(Addr) --> Addr

rules

  log-object-creation(S) --> S
  where
    read(S) --> Obj(O, _, methods);
    concat(separate-by(allkeys(methods), ", ")) --> method-names;
    log("S: " ++ str(S) ++ " O " ++ str(O) ++ " methods: " ++ method-names) --> _.
  
