module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/functions
  trans/semantics/statements

signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
    Obj: Addr * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    SC : Int
    
rules

  S, P Exec() |- ObjectL(inherit, [], code) --> S'
  where
    new-object(S) --> S';
    S S', O S, P Flatten() |- inherit --> FlatObject(closures-inherited);
    concatClosures(closures-inherited, [Closure(S, code)]) => closures;
    S' |- init-slots(closures) --> closures';
    S' |- init-methods(closures') --> closures'';
    S' |- init-object(closures'') --> _.
  
  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.

/* ========== SLOT ALLOCATION ======== */
signature
  arrows
    init-slots(Closures) --> Closures
    alloc-slots(Closures) --> Closures
    Closure -slot-> Closure
    Code -slot-> Code
    
rules
  
  init-slots(closures) --> closures'
  where
    alloc-slots(closures) :: SC 0 --> closures' :: SC _.
  
  alloc-slots([]) --> [].
  
  alloc-slots([clos | closs]) --> [clos' | alloc-slots(closs)]
  where
    clos -slot-> clos'.
  
  Closure(O, code) -slot-> Closure(O, code')
  where
    O |- code -slot-> code'.
  
  [] : Code -slot-> [].
  
  [Declaration(ConstantL(name, _, e)) | ss] : Code -slot-> [SlotWrite(i, e), Declaration(field-getter(name, i)) | ss']
  where
    add-slot(Uninitialized()) --> i;
    ss -slot-> ss'.

  [Declaration(VariableL(name, _)) | ss] : Code -slot-> [Declaration(field-getter(name, i)), Declaration(field-setter(name, i)) | ss']
  where
    add-slot(Uninitialized()) --> i;
    ss -slot-> ss'.
  
  [s | ss] : Code -slot-> [s | ss']
  where
    ss -slot-> ss'. 

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int) --> Declaration
    field-setter(String, Int) --> Declaration
  
rules
  
  field-getter(x, i) --> MethodL(x, NoAnnotations(), [], [SlotRead(i)]).
  
  field-setter(x, i) --> MethodL(x_set, NoAnnotations(), [x_param], [SlotWrite(i, MCallL(x_param, [] : List(Exp)))])
  where
    halt-error("Shit ", "happens") --> _;
    "setter_name" => x_set;
    "param_name" => x_param.
  
/* ========== INIT METHODS =========== */

signature
  arrows
    init-methods(Closures) --> Closures
    Closure -method-> Closure
    Code -method-> Code
    
rules

  init-methods([]) --> [].
  
  init-methods([clos | closs]) --> [clos' | init-methods(closs)]
  where
    clos -method-> clos'.
  
  Closure(O, code) -method-> Closure(O, code')
  where
    O |- code -method-> code'.
  
  [] : Code -method-> [].
  
  [Declaration(m@MethodL(name, _, _, _)) | ss] : Code -method-> ss'
  where
    add-method(name, method-closure(m)) --> _;
    ss -method-> ss'.
  
  [s | ss] : Code -method-> [s | ss']
  where
    ss -method-> ss'.

/* ========= INIT OBJECTS =========== */

signature
  arrows
    init-object(Closures) --> U
    Closure -obj-> U
    Code -obj-> U
    Statement -obj-> U

rules /* init-fields */
  
  s : Statement -obj-> U()
  where
    s --> v.
  
  init-object([]) --> U().
  
  init-object([clos | closs]) --> init-object(closs)
  where
    clos -obj-> U().

  Closure(O, code) -obj-> U()
  where
    O |- code -obj-> U().
  
  [] : Code -obj-> U().
  
  [c |cs] : Code -obj-> U()
  where
    c -obj-> U();
    cs -obj-> U().

/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  components
    P : Phase
    
  sorts
    Closure
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code -> Closure    
    FlatObject: List(Closure) -> V

  native operators
    concatClosures : Closures * Closures -> Closures

  arrows
    Inherit --> V

rules

  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(concatClosures(closures-inherited, [Closure(S, code)])) //FlatObject(closures-inherited ++ [Closure(O, code)])
  where
    P Flatten() |- inherit --> FlatObject(closures-inherited).

  P Flatten() |- MCallRecvL(e, x, es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-call(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _, _) --> v // TODO this is where to check whether the inherit expression actually returns a fresh object
  where
    e --> v.

/* ======== OBJECT META-FUNCTIONS ========= */

signature
  arrows
    new-object(Addr) --> Addr

    add-slot(V) --> Int
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    
    lookup-method(V, String) --> V
    
    current-self() --> V
    current-outer() --> V

rules

  S |- current-self() --> S.
  
  O |- current-outer() --> O.

  new-object(O) --> S
  where
    allocate(Obj(O, {}, {})) --> S.

  S |- add-slot(v) :: SC --> SC :: SC addI(SC, 1)
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {SC |--> v, slots}, methods)) --> _.
  
  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, slots, _).
  
  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, slots, {x |--> v, methods})) --> _.
  
  S, O |- lookup-method(S', x) --> v
  where
    S == S';
    read(S') --> Obj(O', _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        S O, O O' |- lookup-method(O, x) --> v
    }.

  S |- lookup-method(S', x) --> v
  where
    S != S';
    read(S') --> Obj(_, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        halt-error("No method: ", x) --> _;
        DoneV() => v
    }.
    