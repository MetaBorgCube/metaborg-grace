module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/lineups
  trans/semantics/functions
  trans/semantics/statements
  trans/semantics/imports
  trans/semantics/visibility
  
signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
                // outers
    Obj: Addr * List(Addr) * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    
  arrows
    get-scopes(List(Closure)) --> List(Addr)
  
rules

  S, P Exec() |- ObjectL(inherit, uses, code) --> S'
  where
    new-object(S) --> S';
    S S', O S, P Flatten(), Src Inherit() |- inherit --> FlatObject(closures-inherited);
    S S', O S, P Flatten(), Src Trait() |- uses --> FlatObject(closures-used);
    closures-inherited ++ closures-used ++ [Closure(S, code, Bottom())] => closures;
    
    log("pre-install closures from object construction: " ++ str(closures : AST)) --> _;
    read(S') --> Obj(a,_,c,d);
    update(S', Obj(a, get-scopes(closures), c, d)) --> _;
    
    S' |- install-members(closures) --> closures';
    log("post-install closures' from object construction: " ++ str(closures' : AST)) --> _;
    S' |- init-object(closures') --> U();
    log-object-creation(S') --> _.

  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.
    
  get-scopes([]) --> [].
  get-scopes([Closure(addr,_,_) | cs]) --> [addr | get-scopes(cs)].

/* ========== INIT METHODS =========== */

signature
  arrows
    install-members(Closures) --> Closures
    install-members-aux(Closures) --> Closures
    
    Closure -member-> Closure
    Code -member-> Code
    
    install-method(Declaration) --> U
    
rules

  install-members(closures) --> closures'
  where
    install-members-aux(closures) :: NS 0, GS {} --> closures' :: NS _, GS _.

  install-members-aux([]) --> [].
  
  install-members-aux([clos | closs]) --> [clos' | install-members-aux(closs)]
  where
    clos -member-> clos';
    log("-member-> " ++ str(clos) ++ " to " ++ str(clos')) --> _.
  
  Closure(O, code, src) -member-> Closure(O, current-method-names(), code', src)
  where
    O, Src src |- code -member-> code'.
    
  [] : Code -member-> [].
  
  [Declaration(m@MethodL(_, _, _, _, _, _, _)) | cs] : Code -member-> cs'
  where
    install-method(m) --> _;
    cs -member-> cs'.
  
  [Declaration(VariableL(ID(x), _, ann, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i, is-readable(ann))) --> _;
    install-method(field-setter(x, i, is-writable(ann))) --> _;
    cs -member-> cs'.

  [Declaration(VariableL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
  where
    cs -member-> cs'.

  [Import(name, ID(x), ann) | cs] : Code -member-> cs'
    where
      add-slot(x) --> i;
      get-import-object(name) --> iAddr;
      write-slot(i, RefV(iAddr)) --> _;
      install-method(field-getter(x, i, is-readable(ann))) --> _;
      cs -member-> cs'.
  
  [Declaration(ConstantL(ID(x), _, ann, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i, is-readable(ann))) --> _;
    cs -member-> cs'.
    
  [Declaration(ConstantL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
  where
    cs -member-> cs'.
  
  [c | cs] : Code -member-> [c | cs']
  where
    cs -member-> cs'.
  
  install-method(m@MethodL(ID(name), _, _, _, _, _, _)) --> U()
  where
    add-method(name, method-closure(m)) --> _.

/* ========== OBJECT INIT ======== */
signature
  arrows
    init-object(Closures) --> U
    
    Closure -obji-> U
    Code -obji-> U
    Statement -obji -> U
    
rules
  
  init-object([]) --> U().
  
  init-object([clos | closs]) --> init-object(closs)
  where
    clos -obji-> _.
  
  Closure(O, _, code, _) -obji-> U()
  where
    O |- code -obji-> _.
    
  [] : Code -obji-> U().
  
  [c | cs] : Code -obji-> U()
  where
    c -obji-> _;
    cs -obji-> _.

  s : Statement -obji-> U()
  where
    s --> _.

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int, Bool) --> Declaration
    field-setter(String, Int, Bool) --> Declaration

  native operators
    mksettername: String -> String

rules

  field-getter(x, i, c) -->
    MethodL(ID(x), [], to-annotation(c), [], [], no-type(), [SlotRead(i)]).

  field-setter(x, i, c) -->
    MethodL(ID(mksettername(x)), [], to-annotation(c), [ID("p")], [],
      no-type(), [SlotWrite(i, MCallL(ID("p"), [] : List(Exp)))]).

/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    Inherit : Source
    Trait   : Source
    Bottom  : Source
    
  components
    P : Phase
    Src : Source
    
  sorts
    Closure
    Source
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code * Source -> Closure
    Closure: Addr * List(String) * Code * Source -> Closure
    FlatObject: List(Closure) -> V

  arrows
    Inherit --> V
    List(Use) --> V

rules

  S, P Flatten(), Src src |- ObjectL(inherit, uses, code) --> FlatObject(closures-inh
    ++ closures-uses ++ [Closure(S, code, src)])
  where
    log("flattening object, current src: " ++ str(src)) --> _;
    O S, P Flatten(), Src Inherit() |- inherit --> FlatObject(closures-inh);
    O S, P Flatten(), Src Trait() |- uses --> FlatObject(closures-uses).

  P Flatten() |- MCallRecvL(e, ID(x), es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-and-call-qual(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _) --> v
  where
    e --> v@FlatObject(innerflat);
    log("innerflat: " ++ str(innerflat:AST)) --> _.  // TODO this is where to check whether the inherit
                            // expression actually returns a fresh object

  [] : List(Use) --> FlatObject([]).
  [Use(e,_) | uses] : List(Use) --> FlatObject(closures ++ closures')
    where
      e --> FlatObject(closures);
      uses --> FlatObject(closures').

/* ======== OBJECT META-FUNCTIONS ========= */

signature
  arrows
    new-object(Addr) --> Addr

    add-slot(String) --> Int
    
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    check-add-method(String, V) --> U
    check-method-name(String) --> U
    check-method-params(List(Identifier)) --> U
    
    lookup-method(V, String) --> (V * Bool)
    object-exists(Addr) --> Bool
    
    current-self() --> V
    current-outer() --> V
    current-method-names() --> List(String)
    
    is-member(String) --> Bool
    
    outer(Addr) --> V
    self(Addr) --> V
    
  components
    NS : Int // NextSlot
    GS : Map(String, Int) // GivenSlots

rules

  S |- current-self() --> S.
  
  O |- current-outer() --> O.
  
  self(S) --> S.
  
  outer(S) --> O
  where
    read(S) --> Obj(O, _, _, _).
  
  new-object(O) --> S
  where
    allocate(Obj(O, [O], {}, {})) --> S.

  add-slot(x) :: GS --> GS[x] :: GS
  where
    GS[x?] == true.
  
  S |- add-slot(x) :: NS, GS --> NS :: NS addI(NS, 1), GS {x |--> NS, GS}
  where
    GS[x?] == false;
    read(S) --> Obj(O, outers, slots, methods);
    update(S, Obj(O, outers, {NS |--> UninitializedV(), slots}, methods)) --> _.
    
  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, _, slots, _).
  
  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, outers, slots, methods);
    update(S, Obj(O, outers, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, outers, slots, methods);
    log("S: " ++ int2string(S : Int) ++ " O " ++ int2string(O : Int) ++
      " new method: " ++ x ++ " -> " ++ str(v)) --> _;
    check-add-method(x, v) --> _;
    update(S, Obj(O, outers, slots, {x |--> v, methods})) --> _.

  check-add-method(_, ClosV(_,_,ps,_,_,_,_)) --> U()
    where
//     check-method-name(x) --> _; // should be static as is bound to scope
     check-method-params(ps) --> _.

  check-add-method(_, _) --> U()
    where
      log("anything else?") --> _.

  check-method-params([]) --> U().
  check-method-params([WildCard() | ps]) --> check-method-params(ps).
  check-method-params([ID(p) | ps]) --> check-method-params(ps)
    where
      check-add-local(p) --> _.
  
  S |- current-method-names() --> allkeys(methods)
  where
    read(S) --> Obj(_, _, _, methods).
  
  S |- is-member(x) --> methods[x?]
    where
      read(S) --> Obj(_,_,_, methods).
      
//  lookup-method-direct(RefV(recv), x) --> (v, b)
//  where
//    log("lookup-method-direct: '" ++ x ++ "'") --> _;
//    read(recv) --> Obj(_, _, _, methods);
//    case methods[x?] of {
//      true =>
//        methods[x] => v; true => b
//      false =>
//        halt-error("No such method: ", x) --> _;
//        DoneV() => v; false => b
//    }.
  
  S |- lookup-method(S', x) --> (v, b) // basically lookup in self
  where
    S == S';
    log("lookup-method: '" ++ x ++ "', S == S'") --> _;
    read(S') --> Obj(_, _, _, methods);
    case methods[x?] of {
      true =>
        log("found method '" ++ x ++ "' in self: " ++ str(methods:AST)) --> _;
        methods[x] => v; true => b
      false =>
        log("method '" ++ x ++ "' not found in self: " ++ str(methods:AST)) --> _;
        DoneV() => v; false => b
    }.

  S |- lookup-method(S', x) --> (v, b) // lookup in outers
  where
    S != S';
    log("lookup-method: " ++ x ++ ", S != S' S: " ++
          str(S) ++ " O': " ++ str(S') ) --> _;
    read(S) --> self;
    log("initial self: " ++ str(self)) --> _;
    read(S') --> Obj(O', _, _, methods);
    case methods[x?] of {
      true =>
        log("found method '" ++ x ++ "' in outer: " ++ str(methods:AST)) --> _;
        methods[x] => v;
        true => b
      false =>
        object-exists(O') --> outer-exists;
        case outer-exists of {
          true =>
            log("recursing to outer: '" ++ int2string(O':Int) ++
              "' in search of '" ++ x ++ "'") --> _;
            lookup-method(O', x) --> (v, b) // look in outer
          otherwise => DoneV() => v; false => b
        }
    }.

  /*
   * Halts with error if addr is not an existing object on the heap.
   */ 
  object-exists(addr) :: H --> H[addr?].

signature
  arrows
     log-object-creation(Addr) --> Addr

rules

  log-object-creation(S) --> S
  where
    read(S) --> Obj(O, outers, _, methods);
    concat(separate-by(allkeys(methods), ", ")) --> method-names;
    log("S: " ++ int2string(S : Int) ++ " O " ++ int2string(O : Int) ++
      " outers: " ++ str(outers : AST) ++  ", method-names: " ++ method-names
      ++ ", methods: " ++ str(methods : AST)) --> _.
  
