module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/functions
  trans/semantics/statements

signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
    Obj: Addr * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    SC : Int
    
rules

  S, P Exec() |- ObjectL(inherit, [], code) --> S'
  where
    new-object(S) --> S';
    S S', O S, P Flatten() |- inherit --> FlatObject(closures-inherited);
    concatClosures(closures-inherited, [Closure(S, code)]) => closures;
    S' |- install-methods(closures) --> U();
    S' |- init-object(closures) --> U().
  
  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.

/* ========== INIT METHODS =========== */

signature
  arrows
    install-methods(Closures) --> U
    
    Closure -method-> U
    Code -method-> U
    Statement -method -> U
    
rules

  install-methods([]) --> U().
  
  install-methods([clos | closs]) --> install-methods(closs)
  where
    clos -method-> _.
  
  Closure(O, code) -method-> U()
  where
    O |- code -method-> _.
    
  [] : Code -method-> U().
  
  [c | cs] : Code -method-> U()
  where
    c -method-> _;
    cs -method-> _.

  Declaration(m@MethodL(name, _, _, _)) -method-> U()
  where
    add-method(name, method-closure(m)) --> _.
  
  _ : Statement -method -> U().

/* ========== OBJECT INIT ======== */
signature
  arrows
    init-object(Closures) --> U
    init-object-aux(Closures) --> U
    
    Closure -obji-> U
    Code -obji-> U
    Statement -obji -> U
    
rules
  
  init-object(closures) --> U()
  where
    init-object-aux(closures) :: SC 0 --> _ :: SC _.
  
  init-object-aux([]) --> U().
  
  init-object-aux([clos | closs]) --> init-object-aux(closs)
  where
    clos -obji-> _.
  
  Closure(O, code) -obji-> U()
  where
    O |- code -obji-> _.
    
  [] : Code -obji-> U().
  
  [c | cs] : Code -obji-> U()
  where
    c -obji-> _;
    cs -obji-> _.

  Declaration(ConstantL(name, _, e)) -obji-> U()
  where
    add-slot(Uninitialized()) --> i;
    Declaration(field-getter(name, i)) -method-> _;
    SlotWrite(i, e) --> _.

  Declaration(VariableL(name, _)) -obji-> U()
  where
    add-slot(Uninitialized()) --> i;
    Declaration(field-getter(name, i)) -method-> _;
    Declaration(field-setter(name, i)) -method-> _.

  Declaration(MethodL(_, _, _, _)) --> U().

  s : Statement -obji-> U()
  where
    s --> _.

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int) --> Declaration
    field-setter(String, Int) --> Declaration
  
rules
  
  field-getter(x, i) --> MethodL(x, NoAnnotations(), [], [SlotRead(i)]).
  
  field-setter(x, i) --> MethodL(x_set, NoAnnotations(), [x_param], [SlotWrite(i, MCallL(x_param, [] : List(Exp)))])
  where
    halt-error("Shit ", "happens") --> _;
    "setter_name" => x_set;
    "param_name" => x_param.


/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  components
    P : Phase
    
  sorts
    Closure
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code -> Closure    
    FlatObject: List(Closure) -> V

  native operators
    concatClosures : Closures * Closures -> Closures

  arrows
    Inherit --> V

rules

  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(concatClosures(closures-inherited, [Closure(S, code)])) //FlatObject(closures-inherited ++ [Closure(O, code)])
  where
    O S, P Flatten() |- inherit --> FlatObject(closures-inherited).

  P Flatten() |- MCallRecvL(e, x, es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-call(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _, _) --> v // TODO this is where to check whether the inherit expression actually returns a fresh object
  where
    e --> v.

/* ======== OBJECT META-FUNCTIONS ========= */

signature
  arrows
    new-object(Addr) --> Addr

    add-slot(V) --> Int
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    
    lookup-method(V, String) --> V
    
    current-self() --> V
    current-outer() --> V

rules

  S |- current-self() --> S.
  
  O |- current-outer() --> O.

  new-object(O) --> S
  where
    allocate(Obj(O, {}, {})) --> S.

  S |- add-slot(v) :: SC --> SC :: SC addI(SC, 1)
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {SC |--> v, slots}, methods)) --> _.
  
  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, slots, _).
  
  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, slots, {x |--> v, methods})) --> _.
  
  S, O |- lookup-method(S', x) --> v
  where
    S == S';
    read(S') --> Obj(O', _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        S O, O O' |- lookup-method(O, x) --> v
    }.

  S |- lookup-method(S', x) --> v
  where
    S != S';
    read(S') --> Obj(_, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        halt-error("No method: ", x) --> _;
        DoneV() => v
    }.
    