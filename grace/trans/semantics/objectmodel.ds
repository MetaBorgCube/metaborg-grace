module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/environment
  trans/semantics/statements
  trans/semantics/new-store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers

signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Tbl = Map(String, V)

  constructors
    Obj: Addr * Tbl -> Object
    ClosV: Addr * List(String) * Code * Env -> V
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    
  arrows
    add-member(String, V) --> U
    
    lookup-member(V, String) --> V
    
    init-methods(Closures) --> U
    init-fields(Closures) --> U
    
    new-object(Addr) --> Addr
    
    current-self() --> V
    current-outer() --> V

rules

  S, P Exec() |- ol@ObjectL(_, [], _) --> S'
  where
    new-object(S) --> S';
    P Flatten() |- ol --> FlatObject(closures);
    S' |- init-methods(closures) --> U();
    S' |- init-fields(closures) --> U().
    
rules /* member operations */

  new-object(O) --> S
  where
    allocate(Obj(O, {})) --> S.

  S |- current-self() --> S.
  
  O |- current-outer() --> O.

  S |- add-member(x, v) --> U()
  where
    read(S) --> Obj(O, members);
    update(S, Obj(O, { x |--> v, members})) --> _.

  S, O |- lookup-member(S', x) --> v
  where
    S == S';
    read(S') --> Obj(O', members);
    case members[x?] of {
      true =>
        members[x] => v
      false =>
        S O, O O' |- lookup-member(O, x) --> v
    }.

  S |- lookup-member(S', x) --> v
  where
    S != S';
    read(S') --> Obj(_, members);
    case members[x?] of {
      true =>
        members[x] => v
      false =>
        halt-error("No member: ", x) --> _;
        DoneV() => v
    }.


/* ========== INIT METHODS =========== */

signature
  arrows
    Closure -method-> U
    Code -method-> U
    Statement -method-> U

rules

  O |- Declaration(MethodL(name, _, params, code)) -method-> U()
  where
    add-member(name, ClosV(O, params, code, {})) --> U().
  
  _ : Statement -method-> U().

  init-methods([]) --> U().
  
  init-methods([clos | closs]) --> init-methods(closs)
  where
    clos -method-> U().
  
  Closure(O, code) -method-> U()
  where
    O |- code -method-> U().

  [] : Code -method-> U().
  
  [c |cs] : Code -method-> U()
  where
    c -method-> U();
    cs -method-> U().



/* ========== INIT FIELDS =========== */
signature
  arrows
    Closure -field-> U
    Code -field-> U
    Statement -field-> U

rules /* init-fields */
  
  Declaration(ConstantL(name, _, v)) -field-> U()
  where
    add-member(name, v) --> U().
  
  Declaration(VariableL(name, _)) -field-> U()
  where
    add-member(name, Uninitialized()) --> U().
  
  Declaration(MethodL(_, _, _, _)) -field-> U().
  
  s : Statement -field-> U()
  where
    s --> v.
  
  init-fields([]) --> U().
  
  init-fields([clos | closs]) --> init-fields(closs)
  where
    clos -field-> U().

  Closure(O, code) -field-> U()
  where
    O |- code -field-> U().
  
  [] : Code -field-> U().
  
  [c |cs] : Code -field-> U()
  where
    c -field-> U();
    cs -field-> U().


/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  components
    P : Phase
    
  sorts
    Closure
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code -> Closure    
    FlatObject: List(Closure) -> V

  native operators
    concatClosures : Closures * Closures -> Closures

  arrows
    Inherit --> V

rules

  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(concatClosures(closures-inherited, [Closure(S, code)])) //FlatObject(closures-inherited ++ [Closure(O, code)])
  where
    P Flatten() |- inherit --> FlatObject(closures-inherited).

  P Flatten() |- MCallRecvL(e, x, es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-call(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _, _) --> v // TODO this is where to check whether the inherit expression actually returns a fresh object
  where
    e --> v.

    
    
    