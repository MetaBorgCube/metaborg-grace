module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/lineups
  trans/semantics/statements
  trans/semantics/imports
  trans/semantics/visibility
  
signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
    Obj: Addr * List(Addr) * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    
rules

  S, P Exec() |- ObjectL(inherit, uses, code) --> S'
  where
    new-object(S) --> S';
    snapshot-locals() --> L;
    S S', O S, P Flatten() |- inherit --> oc-inherit;
    S S', O S, P Flatten() |- uses --> ocs-use;
    ObjC(S, src-base(), L, code, oc-inherit, ocs-use, [], []) => oc;
    read(S') --> Obj(outer, _, slots, methods);
    update(S', Obj(outer, objc-gather-scopes(oc), slots, methods)) --> _;
    S' |- install-members-top(oc) --> oc';
    S' |- init-object(oc') --> U().

  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.
    





/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  sort aliases
    Source = Int
  
  components
    P : Phase
    Src : Int
    
  constructors
    ObjC: Addr * Source * Env * Code * V * List(V) * List(Alias) * List(Exclude) -> V
    NoObjC: V
    
  arrows
    Inherit --> V
    List(Use) --> List(V)

  arrows
    objc-rec-aliases(V, List(Alias)) --> V
    objc-rec-excludes(V, List(Exclude)) --> V
    objc-gather-scopes(V) --> List(Addr)
    objc-gather-scopes-concat(List(V)) --> List(Addr)
    
    src-base() --> Source
    src-next() --> Source
    src-previous() --> Source
    src-is-base(Source) --> Bool
    
rules

  S, P Flatten(), Src |- ObjectL(inherit, uses, code) --> ObjC(S, Src, L, code, oc-inherit, ocs-use, [], [])
  where
    snapshot-locals() --> L;
    O S, P Flatten() |- inherit --> oc-inherit;
    O S, P Flatten() |- uses --> ocs-use.

  P Flatten() |- MCallRecvL(e, ID(x), es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- call-qualified(recv, x, vs) --> v.

  NoInherit() --> NoObjC().
  
  InheritL(e, aliases, excludes) --> objc-rec-aliases(objc-rec-excludes(oc, excludes), aliases)
  where
    Src src-next() |- e --> oc@ObjC(_, _, _, _, _, _, _, _).
  
  [] : List(Use) --> [].

  [UseL(e, aliases, excludes) | uses] : List(Use) --> [oc'|ocs]
  where
    Src src-next() |- e --> oc;
    objc-rec-aliases(objc-rec-excludes(oc, excludes), aliases) --> oc';
    Src src-next() |- uses --> ocs.



  objc-gather-scopes(NoObjC()) --> [].

  objc-gather-scopes(ObjC(O, _, _, _, inherit, uses, _, _)) --> [O | scopes]
  where
    objc-gather-scopes-concat([inherit | uses]) --> scopes.

  objc-gather-scopes-concat([]) --> [].
  
  objc-gather-scopes-concat([oc | ocs]) --> ocs1 ++ ocs2 
  where
    objc-gather-scopes(oc) --> ocs1;
    objc-gather-scopes-concat(ocs) --> ocs2.

  objc-rec-excludes(ObjC(outer, src, L, code, inherit, use, aliases, _), excludes) --> ObjC(outer, src, L, code, inherit, use, aliases, excludes).
  
  objc-rec-aliases(ObjC(outer, src, L, code, inherit, use, _, excludes), aliases) --> ObjC(outer, src, L, code, inherit, use, aliases, excludes).

  src-base() --> 0.
  
  Src |- src-next() --> addI(Src, 1).
  
  Src |- src-previous() --> addI(Src, -1)
  where
    gtI(Src, 0) == true.
  
  src-is-base(Src) --> eqI(Src, 0). 



/* ========== OBJECT MEMBER INSTALLATION ===== */
signature
  sort aliases
    Aliases = Map(String, String)
    Excludes = Map(String, String)
  
  arrows
    install-members-top(V) --> V
    install-members(V) --> V
    install-members-map(List(V)) --> List(V)
    
    install-code(Code, Aliases, Excludes) --> Code
    
    install-declaration(Declaration, Aliases, Excludes) --> Code
    
    install-import(Statement) --> Code
    
    install-method(Declaration, Aliases, Excludes) --> U
    
    aliases-map(List(Alias)) --> Aliases
    excludes-map(List(Exclude)) --> Excludes
  
rules
  
  install-members-top(v) --> v'
  where
    install-members(v) :: NS 0, GS {} --> v'.

  install-members(NoObjC()) --> NoObjC().
  
  install-members(ObjC(O, Src, L, code, inherit, uses, aliases, excludes)) --> ObjC(O, Src, L, code', inherit', uses', aliases, excludes)
  where
    install-members(inherit) --> inherit';
    install-members-map(uses) --> uses';
    O, Src |- install-code(code, aliases-map(aliases), excludes-map(excludes)) --> code'.
  
  install-members-map([]) --> [].
  
  install-members-map([oc | ocs]) --> [oc' | ocs']
  where
    install-members(oc) --> oc';
    install-members-map(ocs) --> ocs'.
  
  install-code([], _, _) --> [].
  
  install-code([Declaration(d) | code], aliases, excludes) --> decl-code ++ code'
  where
    install-declaration(d, aliases, excludes) --> decl-code;
    install-code(code, aliases, excludes) --> code'.

  install-code([imp@Import(_, _, _) | code], aliases, excludes) --> imp-code ++ code'
  where
    install-import(imp) --> imp-code;
    install-code(code, aliases, excludes) --> code'. 

  install-code([e | code], aliases, excludes) --> [e | code']
  where
    e =!=> Declaration(_);
    e =!=> Import(_, _, _);
    install-code(code, aliases, excludes) --> code'.

  install-declaration(m@MethodL(_, _, _, _, _, _, _), aliases, excludes) --> []
  where
    install-method(m, aliases, excludes) --> _.

  install-declaration(VariableL(ID(x), _, annos, e), aliases, excludes) --> [SlotWrite(i, e)]
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i, is-readable(annos)), aliases, excludes) --> _;
    install-method(field-setter(x, i, is-writable(annos)), aliases, excludes) --> _.

  install-declaration(VariableL(WildCard(), _, _, e), _, _) --> [Expression(e)].

  install-declaration(ConstantL(ID(x), _, annos, e), aliases, excludes) --> [SlotWrite(i, e)]
  where
    add-slot(x) --> i;
    install-method(field-getter(x, i, is-readable(annos)), aliases, excludes) --> _.

  install-declaration(ConstantL(WildCard(), _, _, e), _, _) --> [Expression(e)].
  
  install-import(Import(name, ID(x), annos)) --> []
  where
    add-slot(x) --> i;
    write-slot(i, get-import-object(name)) --> _;
    install-method(field-getter(x, i, is-readable(annos)), {}, {}) --> _.
  
  install-method(m@MethodL(ID(name), [], _, params, param-types, type, code), aliases, excludes) --> U()
  where
    // TODO FIXME: check whether the methods to alias/exclude actually exist
    case aliases[name?] of {
      true =>
        aliases[name] => alias;
        Src src-previous() |- method-closure(MethodL(ID(alias), [], Annotations([Confidential()]), params, param-types, type, code)) --> clos;
        add-method(alias, clos) --> _
      otherwise =>
    };
    case excludes[name?] of {
      false =>
        add-method(name, method-closure(m)) --> _
      otherwise =>
    }.

  aliases-map([]) --> {}.
  
  aliases-map([AliasL(ID(tox), ID(fromx)) | aliases]) --> { fromx |--> tox, alias-map}
  where
    aliases-map(aliases) --> alias-map.

  excludes-map([]) --> {}.

  excludes-map([ExcludeL(ID(x)) | excludes]) --> { x |--> x, excludes-map}
  where
    excludes-map(excludes) --> excludes-map.
  
  
/* ============== OBJECT INIT ========== */
signature
  arrows
    init-object(V) --> U
    init-object-map(List(V)) --> U
    
rules
  
  init-object(NoObjC()) --> U().
  
  init-object(ObjC(O, _, L, code, inherit, used, _, _)) --> U()
  where
    init-object(inherit) --> _;
    init-object-map(used) --> _;
    O |- code :: L --> _.

  init-object-map([]) --> U().
  
  init-object-map([oc | ocs]) --> U()
  where
    init-object(oc) --> _;
    init-object-map(ocs) --> _.

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int, Bool) --> Declaration
    field-setter(String, Int, Bool) --> Declaration

  native operators
    mksettername: String -> String

rules

  field-getter(x, i, c) -->
    MethodL(ID(x), [], to-annotation(c), [], [], no-type(), [SlotRead(i)]).

  field-setter(x, i, c) -->
    MethodL(ID(mksettername(x)), [], to-annotation(c), [ID("p")], [],
      no-type(), [SlotWrite(i, MCallL(ID("p"), [] : List(Exp)))]).



/* ======== OBJECT META-FUNCTIONS ========= */
signature
  sorts
    StatementResult
    
  constructors
    res: Statement -> StatementResult

  arrows
    new-object(Addr) --> Addr

    add-slot(String) --> Int
    
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    
    check-add-method(String, V) --> U
    check-method-params(List(Identifier)) --> U

//    make-aliases(ObjectClosures, List(Alias)) --> ObjectClosures
//    make-alias(ObjectClosures, Alias) --> ObjectClosures
//
//    remove-excludes(ObjectClosures, List(Exclude)) --> ObjectClosures
//    remove-exclude(ObjectClosures, Exclude) --> ObjectClosures
//
//    find-closure(ObjectClosures, ObjectClosures, Identifier) --> (ObjectClosure * ObjectClosures)
//    copy-method(ObjectClosure, Identifier, Identifier) --> ObjectClosure
//    copy-method-aux(List(Statement), Identifier, Identifier) --> StatementResult
//    remove-method(ObjectClosure, Identifier) --> ObjectClosure
//    remove-method-aux(List(Statement), List(Statement), Identifier) --> (List(Statement) * List(Statement))
//    
//    closure-contains-method(ObjectClosure, Identifier) --> Bool
    
    lookup-local-method(V, String) --> V
    lookup-outer-method(V, String) --> V
    
    current-self() --> V
    current-outer() --> V
    current-method-names() --> List(String)
    
    is-member(String) --> Bool
    
    outer(Addr) --> V
    self(Addr) --> V
    
  components
    NS : Int // NextSlot
    GS : Map(String, Int) // GivenSlots

rules

  S |- current-self() --> S.

  O |- current-outer() --> O.

  self(S) --> S.

  outer(S) --> O
  where
    read(S) --> Obj(O, _, _, _).

  new-object(O) --> S
  where
    allocate(Obj(O, [O], {}, {})) --> S.

  add-slot(x) :: GS --> GS[x] :: GS
  where
    GS[x?] == true.

  S |- add-slot(x) :: NS, GS --> NS :: NS addI(NS, 1), GS {x |--> NS, GS}
  where
    GS[x?] == false;
    read(S) --> Obj(O, outers, slots, methods);
    update(S, Obj(O, outers, {NS |--> UninitializedV(), slots}, methods)) --> _.

  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, _, slots, _).

  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, outers, slots, methods);
    update(S, Obj(O, outers, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, outers, slots, methods);
    check-add-method(x, v) --> _;
    update(S, Obj(O, outers, slots, {x |--> v, methods})) --> _.




  check-add-method(_, ClosV(_,_,ps,_,_,_,_,_)) --> U()
  where
    check-method-params(ps) --> _.

  check-add-method(_, _) --> U().

  check-method-params([]) --> U().

  check-method-params([WildCard() | ps]) --> check-method-params(ps).

  check-method-params([ID(p) | ps]) --> check-method-params(ps)
  where
    ensure-valid-local(p) --> _.
  
  
  
  
  
  S |- current-method-names() --> allkeys(methods)
  where
    read(S) --> Obj(_, _, _, methods).





//  make-aliases(closures, []) --> closures
//  where
//    log("make-aliases: no aliases to make") --> _.
//
//  make-aliases(closures, ass@[a | as]) --> make-aliases(closures', as)
//  where
//    log("making aliases: closures: " ++ str(closures:AST) ++ " aliases: " ++ str(ass:AST)) --> _;
//    make-alias(closures, a) --> closures';
//    log("post making alias: closures': " ++ str(closures:AST)) --> _.
//
//  make-alias(closures, AliasL(toId,fromId)) --> [clos' | rest]
//  where
//    find-closure(closures, [], fromId) --> (clos, rest);
//    copy-method(clos, toId, fromId) --> clos'.
//
//  remove-excludes(closures, []) --> closures.
//
//  remove-excludes(closures, exss@[ex | exs]) --> remove-excludes(closures', exs)
//  where
//    remove-exclude(closures, ex) --> closures'.
//
//  remove-exclude(closures, ExcludeL(id)) --> [clos' | rest]
//  where
//    find-closure(closures, [], id) --> (clos, rest);
//    remove-method(clos, id) --> clos'.
//
//  find-closure([], not, ID(name)) --> (U() : ObjectClosure, not) // WTF?!
//  where
//    halt-error("Method to alias/exlude not found: ", name) --> _.
//
//  find-closure([clos | closs], not, id) --> (clos, not ++ closs)
//  where
//    closure-contains-method(clos, id) --> res;
//    res == true.
//
//  find-closure([clos | closs], not, id) --> find-closure(closs, [clos | not], id)
//  where
//    closure-contains-method(clos, id) --> res;
//    res == false.
//
//  closure-contains-method(ObjClos(_,[],_,_), _) --> false.
//
//  closure-contains-method(ObjClos(_, [Declaration(MethodL(ID(mName),_,_,_,_,_,_)) | _ ],_,_), ID(name)) --> true
//  where
//    mName == name.
//
//  closure-contains-method(clos@ObjClos(a, [Declaration(MethodL(ID(mName),_,_,_,_,_,_)) | decs ],c,d), id@ID(name))
//    --> closure-contains-method(ObjClos(a,decs,c,d), id)
//  where
//    log("closure-contains-method Closure(: " ++ str(clos:AST)) --> _;
//    mName != name.
//
//  copy-method(ObjClos(a, sts, c, d), toId, fromId) --> ObjClos(a,[st | sts],c,d)
//  where
//    copy-method-aux(sts, toId, fromId) --> res(st).
//
//  remove-method(ObjClos(a, sts, c, d), id) --> ObjClos(a,sts1 ++ sts2,c,d)
//  where
//    remove-method-aux(sts, [], id) --> (sts1, sts2).
//
//  remove-method-aux([st | sts1], sts2, id@ID(excludeName)) --> remove-method-aux(sts1, [st | sts2], id)
//  where
//    st => Declaration(MethodL(ID(name), _, _, _, _, _, _));
//    name != excludeName.
//
//  remove-method-aux([st | sts1], sts2, ID(excludeName)) --> (sts1,sts2)
//    where
//      st => Declaration(MethodL(ID(name), _, _, _, _, _, _));
//      name == excludeName.
//
//  copy-method-aux([st | sts], toId, fromId@ID(fromName)) --> copy-method-aux(sts, toId, fromId)
//  where
//    st => Declaration(MethodL(ID(name), _, _, _, _, _, _));
//    name != fromName.
//
//  copy-method-aux([st | _], toId, ID(fromName)) -->
//    res(Declaration(MethodL(toId, b, Annotations([Confidential()]),d,e,f,g)))
//  where
//    st => Declaration(MethodL(ID(name), b, _, d, e, f, g));
//    name == fromName.

  S |- current-method-names() --> allkeys(methods)
  where
    read(S) --> Obj(_, _, _, methods).

  S |- is-member(x) --> methods[x?]
  where
    read(S) --> Obj(_,_,_, methods).

  // Lookup in self
  lookup-local-method(RefV(S'), x) --> v
  where
    read(S') --> Obj(_, _, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        DoneV() => v
    }.

  lookup-local-method(v, _) --> DoneV()
  where
    v =!=> RefV(_).

  // Lookup in outers
  lookup-outer-method(RefV(S'), x) --> v
  where
    read(S') --> Obj(O', _, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        is-stored(O') --> outer-exists;
        case outer-exists of {
          true =>
            lookup-outer-method(O', x) --> v
          otherwise =>
            DoneV() => v
        }
    }.

  lookup-outer-method(v, _) --> DoneV()
  where
    v =!=> RefV(_).


signature
  arrows
     log-object-creation(Addr) --> Addr

rules

  log-object-creation(S) --> S
  where
    read(S) --> Obj(O, outers, _, methods);
    concat(separate-by(allkeys(methods), ", ")) --> method-names;
    log("S: " ++ int2string(S : Int) ++ " O " ++ int2string(O : Int) ++
      " outers: " ++ str(outers : AST) ++  ", method-names: " ++ method-names
      ++ ", methods: " ++ str(methods : AST)) --> _.
  
