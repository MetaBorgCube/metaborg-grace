module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/frame
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/lineups
  trans/semantics/functions
  trans/semantics/statements

signature
  sorts
    Phase
  
  constructors
    Exec : Phase
    Layout : Phase

  components
    P : Phase
    BaseF: FrameId
     
  constructors
    RefV : F -> V {implicit}
  
  constructors
    SlotWrite: Path * V -> Statement
    SlotRead: Path -> Statement
  
  arrows
    init-object(F) --> V
    Code -layout-> Code
    Inherit --> V
    
rules

  P Exec() |- ol@ObjectL(_, [], _) --> v
  where
    P Layout() |- ol --> v@RefV(F');
    F', P Exec() |- init-object(F') --> _.

  P Layout() |- ObjectL(inherit, [], code) --> RefV(F3)
  where
    P Layout() |- inherit --> RefV(F2);
    f-new(F2) --> F3;
    f-bind(path(path-member(outer-name())), current-self()) --> _; 
    F3 |- code -layout-> init-code;
    F3 |- f-bind(path(path-member(ctr-name())), method-closure(obj-constructor(init-code))) --> _.
    
  P Layout() |- MCallRecvL(e, ID(x), es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Layout() |- resolve-and-call(recv, x, vs) --> v.

  Inherit(e, _) --> e.
  
  NoInherit() --> base-object().

  init-object(F_self) --> RefV(F_self)
  where
    f-bind(path(path-member(self-name())), RefV(F_self)) --> _;
    f-parent-get() --> F_parent;
    base-object() --> RefV(F_base);
    case eqI(F_parent, F_base) of {
      true =>
        // base object reached
      false =>
        F_parent |- init-object(F_self) --> _;
        resolve-and-call(ctr-name(), []) --> _
    }.

  [Declaration(m@MethodL(ID(x), _, _, _, _, _, _)) | cs] : Code -layout-> cs'
  where
    f-resolve(x) --> method-path;
    case method-path of {
      [NP()] =>
        path(path-member(x)) --> install-path
      otherwise =>
        method-path => install-path
    };
    f-bind(install-path, method-closure(m)) --> _;
    cs -layout-> cs'.
  
  [Declaration(VariableL(ID(x), _, _, e)) | cs] : Code -layout-> [SlotWrite(slot-path, e) | cs']
  where
    f-slot-new(UninitializedV()) --> slot-path;
    f-resolve(getter-name(x)) --> getter-path;
    case getter-path of {
      [NP()] =>
        path(path-member(getter-name(x))) --> getter-install-path
      otherwise =>
        getter-path => getter-install-path
    };
    f-bind(getter-install-path, method-closure(field-getter(x, slot-path))) --> _;
    f-resolve(setter-name(x)) --> setter-path;
    case setter-path of {
      otherwise =>
        setter-path => setter-install-path
    };
    f-bind(setter-install-path, method-closure(field-setter(x, slot-path))) --> _;
    cs -layout-> cs'.
  
  [Declaration(VariableL(WildCard(), _, _, e)) | cs] : Code -layout-> [Expression(e) | cs']
  where
    cs -layout-> cs'.
  
  [Declaration(ConstantL(ID(x), _, _, e)) | cs] : Code -layout-> [SlotWrite(slot-path, e) | cs']
  where
    f-slot-new(UninitializedV()) --> slot-path;
    f-resolve(getter-name(x)) --> getter-path;
    case getter-path of {
      [NP()] =>
        path(path-member(getter-name(x))) --> getter-install-path
      otherwise =>
        getter-path => getter-install-path
    };
//    f-bind(getter-install-path, method-closure(field-getter(x, slot-path))) --> _;
    f-bind(getter-install-path, RefV(42)) --> _;
    cs -layout-> cs'.
  
  [Declaration(ConstantL(WildCard(), _, _, e)) | cs] : Code -layout-> [Expression(e) | cs']
  where
    cs -layout-> cs'.

  [] : Code -layout-> [].
  
  [c | cs] : Code -layout-> [c | cs']
  where
    cs -layout-> cs'.
  
signature
  arrows
    create-base-object() --> V
    base-object() --> V
    
    current-self() --> V
    current-outer() --> V
    
    self-name() --> String
    outer-name() --> String
    ctr-name() --> String
    
    lookup-method(String) --> V
    lookup-method(F, String) --> V
    
    field-getter(String, Path) --> Declaration
    field-setter(String, Path) --> Declaration
    obj-constructor(Code) --> Declaration

    getter-name(String) --> String
    setter-name(String) --> String

  native operators
    mksettername: String -> String

rules

  BaseF |- base-object() --> RefV(BaseF).
  
  create-base-object() --> RefV(F)
  where
    f-new(42) --> F;
    F |- f-parent-set(F) --> _;
    F |- f-bind(path(path-member(self-name())), RefV(F)) --> _;
    F |- f-bind(path(path-member(outer-name())), RefV(F)) --> _.
    
  
  outer-name() --> "outer".
  
  self-name() --> "self".
  
  ctr-name() --> "$_init".
  
  current-self() --> v
  where
    f-resolve(self-name()) --> self-path;
    f-read(self-path) --> v.
  
  current-outer() --> v
  where
    f-resolve(outer-name()) --> outer-path;
    f-read(outer-path) --> v.
  
  obj-constructor(code) --> MethodL(ID(ctr-name()), [], NoAnnotations(), [], [], no-type(), code).
  
  setter-name(x) --> mksettername(x).
  
  getter-name(x) --> x.
  
  field-getter(x, path) --> MethodL(ID(gname), [], NoAnnotations(), [], [], no-type(), [SlotRead(path)])
  where
    getter-name(x) --> gname.
  
  field-setter(x, path) --> MethodL(ID(sname), [], NoAnnotations(), [ID("p")], [], no-type(), [SlotWrite(path, MCallL(ID("p"), [] : List(Exp)))])
  where
    setter-name(x) --> sname.

  //  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(closures-inherited ++ [Closure(S, code)])
//  where
//    O S, P Flatten() |- inherit --> FlatObject(closures-inherited).
//
//  P Flatten() |- MCallRecvL(e, ID(x), es) --> v
//  where
//    P Exec() |- e --> recv;
//    P Exec() |- es --> vs;
//    P Flatten() |- resolve-and-call(recv, x, vs) --> v.
//
//  NoInherit() --> FlatObject([]).
//  
//  Inherit(e, _) --> v
//  where
//    e --> v@FlatObject(_).  // TODO this is where to check whether the inherit expression actually returns a fresh object


//signature
//  sorts
//    Addr
//
//  sorts
//    Object
//    Member
//    
//  sort aliases
//    Self = Addr
//    HeapData = Object
//    Slots = Map(Int, V)
//    Methods = Map(String, V)
//
//  constructors // extra instructions
//    SlotRead : Int -> Statement
//    SlotWrite : Int * Exp -> Statement 
//
//  constructors
//    Obj: Addr * Slots * Methods -> Object
//    RefV: Addr -> V {implicit}
//  
//  components
//    S : Addr
//    O : Addr
//  
//rules
//
//  S, P Exec() |- ObjectL(inherit, [], code) --> S'
//  where
//    new-object(S) --> S';
//    S S', O S, P Flatten() |- inherit --> FlatObject(closures-inherited);
//    closures-inherited ++ [Closure(S, code)] => closures;
//    S' |- install-members(closures) --> closures';
//    S' |- init-object(closures') --> U();
//    log-object-creation(S') --> _.
//  
//  SlotRead(i) --> read-slot(i).
//  
//  SlotWrite(i, e) --> DoneV()
//  where
//    e --> v;
//    write-slot(i, v) --> _.
//
///* ========== INIT METHODS =========== */
//
//signature
//  arrows
//    install-members(Closures) --> Closures
//    install-members-aux(Closures) --> Closures
//    
//    Closure -member-> Closure
//    Code -member-> Code
//    
//    install-method(Declaration) --> U
//    
//rules
//
//  install-members(closures) --> closures'
//  where
//    install-members-aux(closures) :: NS 0, GS {} --> closures' :: NS _, GS _.
//
//  install-members-aux([]) --> [].
//  
//  install-members-aux([clos | closs]) --> [clos' | install-members-aux(closs)]
//  where
//    clos -member-> clos'.
//  
//  Closure(O, code) -member-> Closure(O, current-method-names(), code')
//  where
//    O |- code -member-> code'.
//    
//  [] : Code -member-> [].
//  
//  [Declaration(m@MethodL(_, _, _, _, _, _, _)) | cs] : Code -member-> cs'
//  where
//    install-method(m) --> _;
//    cs -member-> cs'.
//  
//  [Declaration(VariableL(ID(x), _, _, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
//  where
//    add-slot(x) --> i;
//    install-method(field-getter(x, i)) --> _;
//    install-method(field-setter(x, i)) --> _;
//    cs -member-> cs'.
//
//  [Declaration(VariableL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
//  where
//    cs -member-> cs'.
//  
//  [Import(name, ID(x)) | cs] : Code -member-> cs'
//    where
//      add-slot(x) --> i;
//      get-import-object(name) --> iAddr;
//      write-slot(i, RefV(iAddr)) --> _;
//      install-method(field-getter(x, i)) --> _;
//      cs -member-> cs'.
//  
//  [Declaration(ConstantL(ID(x), _, _, e)) | cs] : Code -member-> [SlotWrite(i, e) | cs']
//  where
//    add-slot(x) --> i;
//    install-method(field-getter(x, i)) --> _;
//    cs -member-> cs'.
//    
//  [Declaration(ConstantL(WildCard(), _, _, e)) | cs] : Code -member-> [Expression(e) | cs']
//  where
//    cs -member-> cs'.
//  
//  [c | cs] : Code -member-> [c | cs']
//  where
//    cs -member-> cs'.
//  
//  install-method(m@MethodL(ID(name), _, _, _, _, _, _)) --> U()
//  where
//    add-method(name, method-closure(m)) --> _.
//
///* ========== OBJECT INIT ======== */
//signature
//  arrows
//    init-object(Closures) --> U
//    
//    Closure -obji-> U
//    Code -obji-> U
//    Statement -obji -> U
//    
//rules
//  
//  init-object([]) --> U().
//  
//  init-object([clos | closs]) --> init-object(closs)
//  where
//    clos -obji-> _.
//  
//  Closure(O, M, code) -obji-> U()
//  where
//    M, O |- code -obji-> _.
//    
//  [] : Code -obji-> U().
//  
//  [c | cs] : Code -obji-> U()
//  where
//    c -obji-> _;
//    cs -obji-> _.
//
//  s : Statement -obji-> U()
//  where
//    s --> _.
//
///* ========== FIELD METHOD GENERATION ======= */
//signature
//  arrows
//    field-getter(String, Int) --> Declaration
//    field-setter(String, Int) --> Declaration
//  
//  native operators
//    mksettername: String -> String
//  
//rules
//
//  field-getter(x, i) --> MethodL(ID(x), [], NoAnnotations(), [], [], no-type(), [SlotRead(i)]).
//  
//  field-setter(x, i) --> MethodL(ID(mksettername(x)), [], NoAnnotations(), [ID("p")], [], no-type(), [SlotWrite(i, MCallL(ID("p"), [] : List(Exp)))]).
//
///* ========== OBJECT FLATTENING =========== */
//signature
//  sorts
//    Phase
//  
//  constructors
//    Exec    : Phase
//    Flatten : Phase
//    
//  components
//    P : Phase
//    
//  sorts
//    Closure
//    
//  sort aliases
//    Closures = List(Closure)
//
//  constructors
//    Closure: Addr * Code -> Closure
//    Closure: Addr * List(String) * Code -> Closure
//    FlatObject: List(Closure) -> V
//
//  arrows
//    Inherit --> V
//
//rules
//
//  S, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(closures-inherited ++ [Closure(S, code)])
//  where
//    O S, P Flatten() |- inherit --> FlatObject(closures-inherited).
//
//  P Flatten() |- MCallRecvL(e, ID(x), es) --> v
//  where
//    P Exec() |- e --> recv;
//    P Exec() |- es --> vs;
//    P Flatten() |- resolve-and-call(recv, x, vs) --> v.
//
//  NoInherit() --> FlatObject([]).
//  
//  Inherit(e, _) --> v
//  where
//    e --> v@FlatObject(_).  // TODO this is where to check whether the inherit expression actually returns a fresh object
//
///* ======== OBJECT META-FUNCTIONS ========= */
//
//signature
//  arrows
//    new-object(Addr) --> Addr
//
//    add-slot(String) --> Int
//    
//    read-slot(Int) --> V
//    write-slot(Int, V) --> U
//    
//    add-method(String, V) --> U
//    
//    lookup-method(V, String) --> V
//    
//    current-self() --> V
//    current-outer() --> V
//    current-method-names() --> List(String)
//    
//    outer(Addr) --> V
//    self(Addr) --> V
//    
//  components
//    NS : Int // NextSlot
//    GS : Map(String, Int) // GivenSlots
//
//rules
//
//  S |- current-self() --> S.
//  
//  O |- current-outer() --> O.
//  
//  self(S) --> S.
//  
//  outer(S) --> O
//  where
//    read(S) --> Obj(O, _, _).
//  
//  new-object(O) --> S
//  where
//    allocate(Obj(O, {}, {})) --> S.
//
//  add-slot(x) :: GS --> GS[x] :: GS
//  where
//    GS[x?] == true.
//  
//  S |- add-slot(x) :: NS, GS --> NS :: NS addI(NS, 1), GS {x |--> NS, GS}
//  where
//    GS[x?] == false;
//    read(S) --> Obj(O, slots, methods);
//    update(S, Obj(O, {NS |--> UninitializedV(), slots}, methods)) --> _.
//    
//  S |- read-slot(i) --> slots[i]
//  where
//    read(S) --> Obj(_, slots, _).
//  
//  S |- write-slot(i, v) --> U()
//  where
//    read(S) --> Obj(O, slots, methods);
//    update(S, Obj(O, {i |--> v, slots}, methods)) --> _.
//
//  S |- add-method(x, v) --> U()
//  where
//    read(S) --> Obj(O, slots, methods);
//    log("S: " ++ str(S) ++ " O " ++ str(O) ++ " new method: " ++ x ++ " -> " ++ str(v)) --> _;
//    update(S, Obj(O, slots, {x |--> v, methods})) --> _.
//  
//  S |- current-method-names() --> allkeys(methods)
//  where
//    read(S) --> Obj(_, _, methods).
//  
//  S, O |- lookup-method(S', x) --> v
//  where
//    S == S';
//    read(S') --> Obj(O', _, methods);
//    case methods[x?] of {
//      true =>
//        methods[x] => v
//      false =>
//        S O, O O' |- lookup-method(O, x) --> v
//    }.
//
//  S |- lookup-method(S', x) --> v
//  where
//    S != S';
//    read(S') --> Obj(_, _, methods);
//    case methods[x?] of {
//      true =>
//        methods[x] => v
//      false =>
//        halt-error("No method: ", x) --> _;
//        DoneV() => v
//    }.
//

