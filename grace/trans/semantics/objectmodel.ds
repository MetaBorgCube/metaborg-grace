module trans/semantics/objectmodel

imports
  src-gen/ds-signatures/grace-sig

imports
  trans/semantics/values
  trans/semantics/store
  trans/semantics/runtime/natives
  
  trans/semantics/strings
  trans/semantics/numbers
  trans/semantics/functions
  trans/semantics/statements

signature
  sorts
    Addr

  sorts
    Object
    Member
    
  sort aliases
    Self = Addr
    HeapData = Object
    Slots = Map(Int, V)
    Methods = Map(String, V)

  constructors // extra instructions
    SlotRead : Int -> Statement
    SlotWrite : Int * Exp -> Statement 

  constructors
    Obj: Addr * Slots * Methods -> Object
    RefV: Addr -> V {implicit}
  
  components
    S : Addr
    O : Addr
    SC : Int
    
  arrows
    add-slot(V) --> Int
    read-slot(Int) --> V
    write-slot(Int, V) --> U
    
    add-method(String, V) --> U
    
    lookup-method(V, String) --> V
    
    alloc-slots(Closures) --> U
    init-methods(Closures) --> U
    init-object(Closures) --> U
    
    new-object(Addr) --> Addr
    
    current-self() --> V
    current-outer() --> V

rules

  S, P Exec() |- ol@ObjectL(_, [], _) --> S'
  where
    new-object(S) --> S';
    S S', O S, P Flatten() |- ol --> FlatObject(closures);
    S' |- alloc-slots(closures) --> U();
    S' |- init-methods(closures) --> U();
    S' |- init-object(closures) --> U().
  
  SlotRead(i) --> read-slot(i).
  
  SlotWrite(i, e) --> DoneV()
  where
    e --> v;
    write-slot(i, v) --> _.

rules /* object operations */

  S |- current-self() --> S.
  
  O |- current-outer() --> O.

  new-object(O) --> S
  where
    allocate(Obj(O, {}, {})) --> S.

  S |- add-slot(v) :: SC --> SC :: SC addI(SC, 1)
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {SC |--> v, slots}, methods)) --> _.
  
  S |- read-slot(i) --> slots[i]
  where
    read(S) --> Obj(_, slots, _).
  
  S |- write-slot(i, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, {i |--> v, slots}, methods)) --> _.

  S |- add-method(x, v) --> U()
  where
    read(S) --> Obj(O, slots, methods);
    update(S, Obj(O, slots, {x |--> v, methods})) --> _.
  
  S, O |- lookup-method(S', x) --> v
  where
    S == S';
    read(S') --> Obj(O', _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        S O, O O' |- lookup-method(O, x) --> v
    }.

  S |- lookup-method(S', x) --> v
  where
    S != S';
    read(S') --> Obj(_, _, methods);
    case methods[x?] of {
      true =>
        methods[x] => v
      false =>
        halt-error("No method: ", x) --> _;
        DoneV() => v
    }.

/* ========== SLOT ALLOCATION ======== */
signature
  arrows
    Closure -slot-> U
    Code -slot-> U
    Statement -slot-> U
    
rules

  Declaration(ConstantL(name, _, v)) -slot-> U()
  where
    add-slot(v) --> i;
    field-getter(name, i) --> (name_getter, getter);
    add-method(name_getter, getter) --> _.
  
  Declaration(VariableL(name, _)) -slot-> U()
  where
    add-slot(Uninitialized()) --> i;
    field-getter(name, i) --> (name_getter, getter);
    add-method(name_getter, getter) --> _;
    field-setter(name, i) --> (name_setter, setter);
    add-method(name_setter, setter) --> _.
    
  _ : Statement -slot-> U().
  
  alloc-slots([]) --> U().
  
  alloc-slots([clos | closs]) --> alloc-slots(closs)
  where
    clos -slot-> U().
  
  Closure(O, code) -slot-> U()
  where
    O |- code :: SC 0 -slot-> U() :: SC _.

  [] : Code -slot-> U().
  
  [c |cs] : Code -slot-> U()
  where
    c -slot-> U();
    cs -slot-> U().

/* ========== FIELD METHOD GENERATION ======= */
signature
  arrows
    field-getter(String, Int) --> (String * V)
    field-setter(String, Int) --> (String * V)
  
rules
  
  field-getter(x, i) --> (x, getter)
  where
    method-closure(MethodL(x, NoAnnotations(), [], [SlotRead(i)])) --> getter.
  
  field-setter(x, i) --> (x_set, setter)
  where
    halt-error("Shit ", "happens") --> _;
    "setter_name" => x_set;
    "param_name" => x_param;
    method-closure(MethodL(x_set, NoAnnotations(), [x_param], [SlotWrite(i, MCallL(x_param, [] : List(Exp)))])) --> setter.
  
/* ========== INIT METHODS =========== */

signature
  arrows
    Closure -method-> U
    Code -method-> U
    Statement -method-> U
    
rules

  Declaration(m@MethodL(name, _, _, _)) -method-> U()
  where
    method-closure(m) --> closv;
    add-method(name, closv) --> U().
  
  _ : Statement -method-> U().

  init-methods([]) --> U().
  
  init-methods([clos | closs]) --> init-methods(closs)
  where
    clos -method-> U().
  
  Closure(O, code) -method-> U()
  where
    O |- code -method-> U().

  [] : Code -method-> U().
  
  [c |cs] : Code -method-> U()
  where
    c -method-> U();
    cs -method-> U().

/* ========= INIT OBJECTS =========== */

signature
  arrows
    Closure -init-> U
    Code -init-> U
    Statement -init-> U

rules /* init-fields */
  
  s : Statement -init-> U()
  where
    s --> v.
  
  init-object([]) --> U().
  
  init-object([clos | closs]) --> init-object(closs)
  where
    clos -init-> U().

  Closure(O, code) -init-> U()
  where
    O |- code -init-> U().
  
  [] : Code -init-> U().
  
  [c |cs] : Code -init-> U()
  where
    c -init-> U();
    cs -init-> U().

/* ========== OBJECT FLATTENING =========== */
signature
  sorts
    Phase
  
  constructors
    Exec    : Phase
    Flatten : Phase
    
  components
    P : Phase
    
  sorts
    Closure
    
  sort aliases
    Closures = List(Closure)

  constructors
    Closure: Addr * Code -> Closure    
    FlatObject: List(Closure) -> V

  native operators
    concatClosures : Closures * Closures -> Closures

  arrows
    Inherit --> V

rules

  O, P Flatten() |- ObjectL(inherit, [], code) --> FlatObject(concatClosures(closures-inherited, [Closure(O, code)])) //FlatObject(closures-inherited ++ [Closure(O, code)])
  where
    P Flatten() |- inherit --> FlatObject(closures-inherited).

  P Flatten() |- MCallRecvL(e, x, es) --> v
  where
    P Exec() |- e --> recv;
    P Exec() |- es --> vs;
    P Flatten() |- resolve-call(recv, x, vs) --> v.

  NoInherit() --> FlatObject([]).
  
  Inherit(e, _, _) --> v // TODO this is where to check whether the inherit expression actually returns a fresh object
  where
    e --> v.
    
    