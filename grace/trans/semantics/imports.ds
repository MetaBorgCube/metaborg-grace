module trans/semantics/imports

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig
  trans/semantics/semantics
  trans/semantics/statements

signature

//  sorts
//    Import
//    
  sort aliases
    Import = Map(String, Addr)
  
  components
    D : Import
    I : Import
  
  arrows
    get-dialect-object(List(Statement)) --> Addr
    get-import-object(String) --> V
    parse-file(String) --> AST
    
  native operators
    parse_file: String -> Program
    
rules

  parse-file(s) --> parse_file(s).
//  read-import(s) --> read_import(s).

  S |- get-dialect-object([Expression(ObjectL(_,_,[Dialect("none") | _ ])) | _ ]) --> new-object(S)
  where
    log("file has dialect 'none', giving back empty object") --> _.

  get-dialect-object([Expression(ObjectL(_,_,[Dialect(name) | _ ])) | _ ]) :: D --> objectAddr :: D'
  where
    log("reading dialect: " ++ name) --> _;
    fresh => no-object;
    case D[name?] of {
      true =>
        D[name] => objectAddr; //v@FlatObject(_);
        D => D'
      otherwise =>
        // read the dialect ast
        parse-file(name) --> p@Program(_);
        // actually execute the dialect
        p : Program :: D --> RefV(objectAddr);
        // set dialect name as already read
        {name |--> objectAddr, D} => D';
        // remove outerchain from dialect
        read(objectAddr) --> Obj(_, a, b, c);
        update(objectAddr, Obj(no-object : Addr, a, b, c)) --> _
      }.

  
  get-dialect-object(_) --> addr
  where
    get-dialect-object([Expression(ObjectL(NoInherit(),[] : List(Use),[Dialect("standardGrace")]))]) --> addr.

  get-import-object(name) :: I --> RefV(objectAddr) :: I'
  where
    case I[name?] of {
      true =>
        I[name] => objectAddr;
        I => I'
      otherwise =>
        parse-file(name) --> Program(code);
        next() --> base;
        S base , O base |- Program(code) :: I --> RefV(objectAddr) :: I'';
        {name |--> objectAddr, I''} => I'
    }.
