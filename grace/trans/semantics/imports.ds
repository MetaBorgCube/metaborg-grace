module trans/semantics/imports

imports
  trans/semantics/semantics
  trans/semantics/statements
  
signature

//  sorts
//    Import
//    
  sort aliases
    Import = Map(String, Addr)
  
  components
    D : Import
    I : Import
  
  arrows
    get-dialect-object(List(Statement)) --> Addr
    read-dialect(String) --> AST
    read-import(String) --> AST
    
  native operators
    read_dialect: String -> AST
    read_import: String -> AST
    
rules

  read-dialect(s) --> read_dialect(s).
  
  S S |- get-dialect-object([Dialect(name) | _] : List(Statement)) :: D --> objectAddr :: D'
    where
      read-dialect(name) --> Program(code,_);
      fresh => no-object;
      case D[name?] of {
        true =>
          case D[name] of {
            1 => // currently evaluating, ignore! TODO make this more elegant
              // what is the dialect of the outermost dialect? empty.
              new-object(S) --> objectAddr;
              D => D'
            otherwise =>
              D[name] => objectAddr; //v@FlatObject(_);
              D => D'
          }
        otherwise =>
          // set dialect as 'currently evaluating'
          {name |--> 1 : Addr, D} => D'';
          // actually execute the dialect
          Program(code, "") :: D'' --> v@RefV(objectAddr);
          // set dialect name as already read
          {name |--> objectAddr, D} => D';
          // remove outerchain from dialect
          read(objectAddr) --> Obj(_, b, c);
          update(objectAddr, Obj(no-object : Addr, b, c)) --> _
        }.
  
  get-dialect-object([Expression(ObjectL(_,_,code)) | b] : List(Statement)) -->
    get-dialect-object(code ++ b). 
    
  get-dialect-object([ a | b ] : List(Statement)) --> get-dialect-object(b)
    where
      a =!=> Dialect(_). 
  
  get-dialect-object([] : List(Statement)) --> addr
    where
      get-dialect-object([Dialect("standardGrace")]) --> addr.
      
  Import(name, id) :: I --> v :: I'
    where
      log("Handling import: " ++ name ++ "'...") --> _;
      DoneV() => v;
      I => I'.
//      read-dialect(name) --> Program(code,_);
//      case I[name] of {
//        StoredImport(v@FlatObject(_)) =>
//          // add slot -> name to v like a constant
//          DoneV() => v;
//          I => I'
//        otherwise =>
//          code --> v@FlatObject(_);
//          StoredImport(v) => sd;
//          {name |--> sd, I} => I'       
//      }.
