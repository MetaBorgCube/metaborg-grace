module trans/semantics/imports

imports
  src-gen/ds-signatures/grace-sig
  src-gen/ds-signatures/grace-lowered-sig
  trans/semantics/semantics
  trans/semantics/statements
  
signature
  sort aliases
    Addr = Int
    
  components
    DCache : Map(String, Addr)
    ICache : Map(String, Addr)
  
  arrows
    collect-dialect-statement(Program) --> Statement
    load-dialect(Statement) --> Addr
    
    get-import-object(String) --> V
    
    
    parse-dialect(String) --> Program
    parse-import(String) --> Program
    
    dialect-cache-is-cached(String) --> Bool
    dialect-cache-add(String, Addr) --> Addr
    dialect-cache-get(String) --> Addr
    
  native operators
    native-parse-dialect: String -> Program
    native-term-origin-path: AST -> String

rules
  
  parse-dialect(s) --> native-parse-dialect(s).
  
  S |- load-dialect(Dialect("none")) --> new-object(S)
  where
    current-self() --> RefV(S).
  
  load-dialect(Dialect(name)) --> dialect-cache-get(name)
  where
    dialect-cache-is-cached(name) --> true.

  load-dialect(d@Dialect(name)) --> dialect
  where
    dialect-cache-is-cached(name) --> false;
    parse-dialect(name) --> program;
    program --> RefV(dialect);
    read(dialect) --> Obj(_, outers, slots, methods);
    update(dialect, Obj(fresh, outers, slots, methods)) --> _;
    dialect-cache-add(name, dialect) --> _.

  collect-dialect-statement(Program([Expression(ObjectL(_,_,[dialect@Dialect(_) | _ ])) | _])) --> dialect.
  
  collect-dialect-statement(Program([Expression(ObjectL(_,_,[stm | _ ])) | _])) --> Dialect("standardGrace")
  where
    stm =!=> Dialect(_).
  
  
  DCache |- dialect-cache-is-cached(name) --> DCache[name?].
  
  dialect-cache-add(name, dialect) :: DCache --> dialect :: DCache { name |--> dialect, DCache}.
  
  dialect-cache-get(name) :: DCache --> DCache[name] :: DCache.
  
rules

  parse-dialect(s) --> native-parse-dialect(s).

  get-import-object(name) :: ICache --> RefV(objectAddr) :: ICache'
  where
    case ICache[name?] of {
      true =>
        ICache[name] => objectAddr;
        ICache => ICache'
      otherwise =>
        parse-import(name) --> Program(code);
        next() --> base;
        S base , O base |- Program(code) :: ICache --> RefV(objectAddr) :: ICache'';
        {name |--> objectAddr, ICache''} => ICache'
    }.
