module trans/desugar/desugar

imports
    
    src-gen/signatures/grace-sig
    src-gen/signatures/grace-lowered-sig
    src-gen/signatures/general-sig
    
    trans/desugar/desugar-common
    trans/desugar/desugar-matchcase
    trans/desugar/lower

rules
  
  desugar-pre = desugar-program <+ desugar-fail

  desugar-all = innermost(desugar)
  
  desugar =
    desugar-class-declaration
    <+ desugar-missing-return-types
    <+ desugar-missing-annotated-types
    <+ desugar-match-case
    <+ desugar-flatten-methodID
    <+ desugar-flatten-methodPart
    <+ desugar-mcallopexp
    <+ desugar-mcallopexpassign
    <+ desugar-mcallprefixopexp
//    <+ desugar-blockExp
    <+ desugar-block
    <+ desugar-arg-noargs
    <+ desugar-arg-argsparen
    <+ desugar-argBlock
    <+ desugar-flatten-objectdecl
    <+ desugar-flatten-declaration
    <+ desugar-unquote-strings
  
  desugar-all-post: ast -> <lower-post-all> <lower-all> ast

  desugar-program: Program(a, b) ->
    Program([Expression(ObjectDecl(NoInherit(), [], a))], b)
  
  desugar-missing-return-types: NoRH() -> RH(TypeID(ID("Unknown"), NoTypeArg()))
  
  desugar-missing-annotated-types: NoTypeAnn() ->
    TypeAnn(TypeID(ID("Unknown"), NoTypeArg()))
  
  desugar-class-declaration:
    ClassDecl(MethodName(mIDs), type, inh, use, code) ->
      MethodDecl(
        mIDs,
        NoAnnotations(),
        type,
        MethodBody([
          Expression(ObjectDecl(inh,use,code))
        ])
      )
  desugar-class-declaration:
    ClassDecl(FullStop(iden, mIDs), type, inh, use, code) ->      
      Constant(iden, NoTypeAnn(), NoAnnotations(), Expression (
        ObjectDecl(NoInherit(), [], [
          MethodDecl(
            mIDs,
            NoAnnotations(),
            type,
            MethodBody([
              Expression(ObjectDecl(inh,use,code))
            ])
          )
        ])
      ))
  
  desugar-flatten-methodID: [ MethodID(ID(n), typeArg, Params(ps)) ] -> 
      [ MethodID(ID(name), typeArg, Params(ps)) ]
    where
      name := <concat-strings> [n, <param-string> ps];
      <not-substring(!"(")> n;
      <debug(!"did the not-substring thing")> name
      
  desugar-flatten-methodID: [ MethodID(ID(n1), typeArg1, Params(p1)),
                              MethodID(ID(n2), typeArg2, Params(p2)) | mids ] ->
      [MethodID(ID(name), types, Params(ps)) | mids ]
    where
      types := <merge-typeargs> [typeArg1, typeArg2];
      name := <concat-strings> [n1, <param-string> p1, n2, <param-string> p2];
      ps   := <concat> [p1,p2];
      <not-substring(!"(")> n1

  desugar-flatten-methodID: [ MethodID(ID(n1), typeArg1, Params(p1)),
                              MethodID(ID(n2), typeArg2, Params(p2)) | mids ] ->
      [MethodID(ID(name), types, Params(ps)) | mids ]
    where
      types := <merge-typeargs> [typeArg1, typeArg2];
      name := <concat-strings> [n1, n2, <param-string> p2];
      ps   := <concat> [p1,p2]

  
  merge-typeargs: [ TypeArg(ls) , TypeArg(ls2) ] -> TypeArg(<concat> [ls,ls2])
  merge-typeargs: [ NoTypeArg() , TypeArg(ls2) ] -> TypeArg(ls2)
  merge-typeargs: [ TypeArg(ls) , NoTypeArg()  ] -> TypeArg(ls)
  merge-typeargs: [ NoTypeArg() , NoTypeArg()  ] -> NoTypeArg()
   
  not-substring(s) = is-substring(s) < fail + id
  
  desugar-flatten-methodPart: [Part(ID(n), NoArgs())] -> <fail>
  desugar-flatten-methodPart: [Part(ID(n), a@_)] -> [Part(ID(name), a)]
    where
      name := <concat-strings> [n, <param-string> a];
      <is-argument> a;
      // only if n does not contain (
      <not-substring(!"(")> n
  desugar-flatten-methodPart: [Part(ID(n1), args1), Part(ID(n2), args2) | ps ] ->
      [Part(ID(name), ArgsParen(args)) | ps]
    where
      name := <concat-strings> [n1, <param-string> args1, n2, <param-string> args2];
      args := <flatten-list> <map(desugar-arg)> [args1, args2];
      // make sure to process first list only once.
      <not-substring(!"(")> n1
      
  desugar-flatten-methodPart: [Part(ID(n1), args1), Part(ID(n2), args2) | ps ] ->
      [Part(ID(name), ArgsParen(args)) | ps]
    with
      name := <concat-strings> [n1, n2, <param-string> args2];
      args := <flatten-list> <map(desugar-arg)> [args1, args2]
      
  param-string: ps ->
    <concat-strings> <flatten-list> <concat> [ ["("] , <commas> <map(!"_")> ps , [")"]]
      where
        <is-list> ps
  
  param-string: a@ArgsParen(ps) -> <param-string> ps
  param-string: a@p -> "(_)"

  commas: [] -> []
  commas: [ a | [] ] -> [ a ]
  commas: [ a | as ] -> [ a , "," | <commas> as]

  neq(|a,b) = equal(|a, b) < fail + id
  
  is-argument: a -> a
    where
       <neq(|a, NoArgs())> a

  desugar-mcallopexp: MCallOpEx(recv, OperatorCF(name), arg)->
    MCallWDot(recv, [Part(ID(name), ArgsParen([arg]))])
  
  desugar-mcallopexpassign: MCallOpExAssign(MCallWDot(recv, [Part(ID(name), NoArgs())]), arg) ->
    MCallWDot(recv, [Part(ID(<concat-strings> [name, ":=(_)"]), 
      ArgsParen([arg])
    )])
    
  desugar-mcallopexpassign: MCallOpExAssign(MCallImpl([Part(ID(name), NoArgs())]), arg) ->
    MCallImpl([Part(ID(<concat-strings> [name, ":="]), ArgsParen([arg]))])

  desugar-mcallprefixopexp: MCallPrefixOpExp(OperatorCF( op ), arg ) ->
    MCallWDot(arg, [Part(ID(<concat-strings> ["prefix", op]), NoArgs())])
  
  desugar-flatten-objectdecl: ObjectDecl(a, b, xs) -> ObjectDecl(a, b, ys)
    where
      ys := <flatten-list> xs;
      <not(eq)> (xs, ys)
        
  desugar-flatten-declaration: Declaration([a, b]) ->
      [Declaration(a), Declaration(b)]

  desugar-arg:  ArgNumber(a) -> Number(a)
  desugar-arg: ArgBoolean(a) -> Boolean(a)
  desugar-arg:  ArgString(a) -> String(a)
  desugar-arg:  ArgLineup(a) -> LineupExp(a)
  desugar-arg:  ArgsParen(a) -> a
  desugar-arg:             a -> a

  desugar-arg-noargs: ArgsParen(as) -> ArgsParen(as')
    where
      as' := <flatten-list> <filter-no-args> as;
      <not(eq)> (as, as')

  filter-no-args: [NoArgs() | as] -> [<filter-no-args> as]  
  filter-no-args: [a | as] -> [a | <filter-no-args> as]
  filter-no-args: [] -> []
  
  desugar-arg-argsparen: ArgsParen(as@[_ | _]) ->
    ArgsParen( <flatten-list> <map(strip-argsparen)> as)
  
  strip-argsparen: ArgsParen(a) -> a
  
  desugar-argBlock: ArgBlock(o) -> ArgsParen([BlockExp(o)])
//  desugar-blockExp: BlockExp(e) -> e
  
  desugar-block:
    Block(BlockWParams(a, b)) -> BlockWParams(a, b)
   
  desugar-block:
    Block(a) -> BlockWParams(BlockParams([]), a) 

  desugar-unquote-strings:
    String(s) -> String(<unquote(?'"')> s)

  desugar-unquote-strings:
    ArgString(s) -> ArgString(<unquote(?'"')> s)
    
  desugar-unquote-strings:
    CString(s) -> CString(<unquote(?'"')> s)
    
  desugar-unquote-strings:
    Dialect(s) -> Dialect(<unquote(?'"')> s)
    
  desugar-fail: a -> <fail>