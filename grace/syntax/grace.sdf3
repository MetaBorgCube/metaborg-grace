module grace

imports

  General
  KeywordRejections

context-free start-symbols
  
  Program
  Exp

context-free syntax

  Program.Program               = <<{CodeSequence "\n"}*> <EOF>>
  
  CodeSequence.Dialect          = <dialect <STRING>>
  CodeSequence.Import           = <import <STRING> as <ID>>
  CodeSequence.Assignment       = <<Assignment>;>
  CodeSequence.Declaration 		= <<Declaration>;> {avoid}
  CodeSequence.Expression       = <<Exp>;>

  Assignment.Assignment         = <<ID> := <Exp>>
  
  // def must be initialized
  Declaration.Constant          = <def <ID><Annotations> = <Exp>> 
  // var has optional init
  Declaration.Variable          = <var <ID><Annotations><VarInit>> 
  Declaration.ActualType        = <<Identifier> <Annotations> <Params>> 
  
  VarInit.VarInit               = < := <Exp>>
  VarInit.NoVarInit             = <>
  
  Declaration.ClassDecl         = <
                                    class <MethodName+>{
                                      <Inherit><Use*><{CodeSequence "\n"}*>
                                    }
                                  >
  Declaration.TraitDecl         = <trait <MethodName+> <MethodBody>>
  
  Use.Use                       = <
									use <Exp><Alias><Exclude>;

								  >
  
  // renmae methodtype to returntype? check docs
  Declaration.MethodDecl        = <method <Prefix><MethodName+><Annotations> <MethodBody>>
  // rename argtype to typearg
  MethodName.MethodID          = <<Identifier> <Params>>
  MethodName.MethodOp          = <<OperatorCF> <Params>>
  
  Prefix.Prefix                 = "prefix"
  Prefix.NoPrefix               = <>
  
  Identifier.ID                 = <<ID>>
  
  Annotations.Annotations       = < is <{Annotation ", "}+>>
  Annotations.NoAnnotations     = <>
  
  Annotation.Public             = "public"
  Annotation.Readable           = "readable"
  Annotation.Writeable          = "writable"
  Annotation.Confidential       = "confidential"
  Annotation.Manifest           = "manifest"
  Annotation.Overrides          = "overrides"
  
  Params.Params                 = <(<{Param ", "}*>)>
  Params.NoParams               = <>
  Param.Param                   = <<ID>>
  PrefixParam.SingleParam       = <<Param>>
  PrefixParam.SingleParamParen  = <(<Param>)>

  MethodBody.MethodBody         = <
									{
									  <{CodeSequence "\n"}*>
									}
								  >
  
  Exp.ObjectDecl                = <
									object {
									  <Inherit><Use*><{CodeSequence "\n"}*>
									}
								  >
  
  Inherit.Inherit               = <
                                    inherit <Exp><Alias><Exclude>;
                                    
  								  >
  Inherit.NoInherit             = <>
  
  Alias.Alias                   = < alias <ID> as <ID>>
  Alias.NoAlias                 = <>
  
  Exclude.Exclude               = < exclude <{ID ", "}*>>
  Exclude.NoExclude             = <>
  
  // simple expressions
  Exp.Number                    = <<NUM>>
  Exp.String                    = <<STRING>>
  Exp.Boolean                   = <<Boolean>>
  Boolean.True                  = "true"
  Boolean.False                 = "false"
  
  // simple "built-in" identifiers
  Exp.Self                       = "self"
//  ID.Outer                      = <<Outer>>
  
  Exp.Outer                      = "outer"
  Exp.PlaceHolder                = "_"
  
  Exp                           = <(<Exp>)>										{bracket}

//  Exp.MCall                     = <<Exp> . <Identifier> <ArgType>>             {left, avoid}
//  Exp.MCallOp                   = <<Exp> <OperatorCF> <ArgType> <CallArgs>>    {left}
  Exp.MCallOpEx                 = <<Exp> <OperatorCF> <Exp>>					{left}
  Exp.MCallWDot                 = <<Exp>.<Part+>>								{left}
  Exp.MCallImpl                 = <<Part+>>										{left}
  Exp.MCallPrefixOp             = <<OperatorCF> <CallArgs>>						{left}
  Exp.MCallPrefixOpExp          = <<OperatorCF> <Exp>>							{left}
  
  OperatorCF.OperatorCF         = <<Operator>>
    
  Part.Part                     = <<Identifier><CallArgs>>
  
  // arguments between parenthesis
  CallArgs.ArgsParen            = < (<{Exp ", "}+>)> {left}
  CallArgs.NoArgs               = <>

  // arguments that are valid without parenthesis
  CallArgs.ArgBlock             = < <Block>>
  CallArgs.ArgNumber            = < <NUM>>
  CallArgs.ArgString            = < <STRING>>
  CallArgs.ArgLineup            = < <Lineup>>
  CallArgs.ArgBoolean           = < <Boolean>>
  
  Exp.LineupExp                 = <<Lineup>>
  Lineup.Lineup                 = <[ <{Exp ", "}*> ]>
  Exp.Ellipsis                  = "..." // needs to yield _runtime_ error
  Exp.BlockExp                  = <<Block>>
  Block.Block                   = <{ <{CodeSequence "\n"}*> }>
  Block.BlockWParams            = <{ <BlockParams> <{CodeSequence "\n"}*> }>          {prefer}
  
  Exp.Return                    = <return <Exp>>
  
  BlockParams.BlockParams       = [[{Param ", "}*] ->]

  
//context-free priorities
    
//    { left: Exp.MCallWDot Exp.MCall Exp.MCallOp Exp.MCallOpEx Exp.MCallImpl Exp.MCallCanonical }