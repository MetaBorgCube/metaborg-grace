module trans/semantics

imports
  src-gen/ds-signatures/Grace-sig
  
  trans/values
  trans/store
  trans/environment

signature
  
  constructors
    Object: O * O * Env -> O // the enclosing object, inherited object, and its bound names
    Trait: Env -> O // basically just a list of mappings of function names to memory locations
    Method: List(String) * Env * List(CodeSequence) -> O // env of declaration and code
    NoObject: O
    Wrapped: V -> CodeSequence
    WrappedO: O -> V
    
    saveConstMethod: Env * String * V --> Env
    getParamNames: Params --> List(String)
    saveConstants: Env * List(String) * List(V) --> Env
    evalArgs: CallArgs --> List(V)
    
  arrows
    Exp --> V
    Boolean --> V
    CodeSequence --> V
    Declaration --> V
    Assignment --> V
    CallArgs --> V
    List(CodeSequence) --> V
//    List(V) --> V
    
    Params --> List(String)
//    CallArgs --> List(V)
    
    Program -init-> V
    
    Exp -o-> O
    Declaration -o-> O
    
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativeIfThenElse: Bool * V * V -> V
    nativeSPrint: String -> String
    nativeIPrint: Int -> Int
    
rules

  Program(cs, _) -init-> cs'
    where
      O NoObject() |- cs :: Env {}, Heap {}, OHeap {} --> cs' :: Env _, Heap _, OHeap _.
  
//  Env eEnc |- ObjectDecl(Inherit(inhExp,_,_), [Use(useExp,_,_)], cs) :: E -o-> Object(eEnc, e', cs)
//    where
//      // 1. create empty object
//      // 2. bind self (env + {})
//      // 3. evalute inherit (recurse) and merge into
//      // 4. evaluate traits and merge into (override inherit)
//      // 5. evaluate local method definitions and merge (override inherit and traits)
//      // 6. evaluate fields and statements. (deferred)
//      Object(eEnc,  E, cs) => self; // create blank object 1
//      
//      E |- bindName("self", allocateO(self)) --> eSelf; // 2
//      
//      inhExp :: Env eSelf -o-> Object(eInh, eInhEnc, csInh); // 3
//      
//      Env eInhEnc |- csInh :: Env eInh --> _ :: Env EAfterInh; //
//      
//      useExp :: Env eInh --> Trait(eTrait); // 4
//      
//      {eTrait, EAfterInh} => e'.
//  
  
//  Object(oEnc, oInh, env) --> v
//    where
//      print(StringV("evalutating object after defer")) => _;
//      Env eEnc |- cs :: Env e --> v.
      
  O encO |- ObjectDecl(NoInherit(), [], cs)  :: E, H, OH -->
                WrappedO(Object(Object(encO, NoObject(), E), NoObject(), E')) :: E', H', OH'
    where
      print(StringV("directly evaluating object")) => _;
      print(getOHeap(OH)) => _;
      O Object(encO, NoObject(), E) |- cs :: E, H, OH  --> _ :: E', H', OH';
      print(StringV("done directly evaluating object")) => _;
      print(getOHeap(OH')) => _;
      print(StringV("==========")) => _.

  Expression(e) --> e.
  Declaration(e) --> e.
  Wrapped(v) --> v.
  Assignment(e) --> e.
    
  cs : List(CodeSequence) :: Env e, H, OH --> v :: Env eFinal, H'', OH''
  where
    case cs of {
        [] =>
            Done() => v;
            e => eFinal;
            H => H'';
            OH => OH''
        [code|[]] =>
            code :: Env e, H, OH --> v :: Env eFinal, H'', OH''
        [code | cs'] =>
            code :: Env e --> _ :: Env e', H', OH';
            cs' :: Env e', H', OH' --> v :: Env eFinal, H'', OH''
    }.
  
  Number(s) --> NumV(parseNumber(s)).
  ArgNumber(s) --> NumV(parseNumber(s)).
  ArgBoolean(s) --> s.
  ArgString(s) --> StringV(s).
  String(s) --> StringV(s).
  True() --> BoolV(true).
  False() --> BoolV(false).
  Boolean(s) --> s.

  saveConstants(startEnv, names, values) :: E, H, OH --> eFinal :: E'', H'', OH''
    where
      case names of {
        [] =>
          {} => eFinal;
          E => E'';
          H => H'';
          OH => OH''
        [n | []] =>
          values => [ v | [] ];
          saveConstMethod(startEnv, n, v) :: E, H, OH --> eFinal :: E'', H'', OH'';
        [n | ns] =>
          values => [v|vs];
          saveConstMethod(startEnv, n, v) :: E, H, OH --> e :: E', H', OH';
          saveConstants(startEnv, ns, vs) :: E', H', OH' --> em :: E'', H'', OH'';
          {em, e} => eFinal
      }.
  
  saveConstMethod(startEnv, name, v) :: E, H, OH --> e' :: E, H', OH'
    where 
      print(StringV("saving const method")) => _;
      print(getOHeap(OH)) => _;
      fresh => i;
      writeO(i, Method([], startEnv, [Wrapped(v)])) :: H, OH  --> _ :: H', OH';
      bindName(name, i) :: E --> e';
      print(StringV("==end saving const method==")) => _.

  evalArgs(ArgsParen(actualArgs)) :: E, H, OH --> agvs: List(V) :: E', H', OH'
    where
      print(StringV("evalArgs (ArgsParen)")) => _;
      case actualArgs of {
        [] =>
          [] => agvs;
          E => E';
          H => H';
          OH => OH'
        [ arg | [] ] =>
          arg --> pv1;
          E => E';
          H => H';
          OH => OH';
          [pv1] => agvs
        [ arg | args ] => 
          arg --> pv1;
          evalArgs(ArgsParen(args)) :: E, H, OH --> pvs :: E', H', OH';
          [pv1 | pvs ] => agvs
      }.

  evalArgs(NoArgs()) --> [] where print(StringV("evalArgs (NoArgs)")) => _.
  evalArgs(v) --> [v] where print(StringV("evalArgs (direct)")) => _.

  MCallImpl([Part(ID(name),NoArgType(),NoArgs())]) :: E, H, OH --> v :: E, H, OH
    where
      readO(readName(name)) --> Method([], e, cs);
      cs :: Env {E, e} --> v. // add local env constants (dynamic scoping)

  MCallImpl([Part(ID(name),NoArgType(),arguments)]) :: E, H, OH --> v :: E, H, OH
    where
      name == "base_print";
      print(StringV("executing base_print (StringV)")) => _;
      print(StringV("evaluating arguments")) => _;
//      print(arguments) => _;
      evalArgs(arguments) :: E, H, OH --> argVs;
      argVs => [StringV(s1)];
      print(StringV("calling base_print method")) => _;
      nativeSPrint(s1) => _;
      Done() => v.
      
  MCallImpl([Part(ID(name),NoArgType(),arguments)]) :: E, H, OH --> v :: E, H, OH
    where
      name == "base_print";
      print(StringV("executing base_print (NumV)")) => _;
      print(StringV("evaluating arguments")) => _;
//      print(arguments) => _;
      evalArgs(arguments) :: E, H, OH --> [NumV(i1)];
      print(StringV("calling base_print method")) => _;
      nativeIPrint(i1) => _;
      Done() => v.
  
  MCallImpl([Part(ID(name),NoArgType(),arguments)]) :: E, H, OH --> v :: E, H, OH
    where
      name == "base_add";
      print(StringV("evaluating arguments")) => _;
//      print(arguments) => _;
      evalArgs(arguments) :: E, H, OH --> [NumV(i1), NumV(i2)];
      print(StringV("calling base_add method")) => _;
      NumV(nativeIBinOp("+", i1, i2)) => v;
      print(v) => _.
        
  MCallImpl([Part(ID(name),NoArgType(),arguments)]) :: E, H, OH --> v :: E, H, OH
    where
      name == "base_ifThenElse";
      print(StringV("evaluating arguments")) => _;
//      print(arguments) => _;
      evalArgs(arguments) :: E, H, OH --> [BoolV(b), e1, e2];
      print(StringV("calling base_add method")) => _;
      nativeIfThenElse(b, e1, e2) => v;
//      case b of {
//        true =>
//          e1 :: E, H, OH --> v
//        otherwise =>
//          e2 :: E, H, OH --> v
//      };
      print(v) => _.

  MCallImpl([Part(ID(name),NoArgType(),arguments)]) :: E, H, OH --> v :: E, H, OH
    where
      name != "base_add";
      name != "base_ifThenElse";
      name != "base_print";
      print(StringV("calling real method")) => _;
      readName(name) :: E --> i;
      print(StringV("read name")) => _;
      evalArgs(arguments) --> actualArgsVs;
      print(StringV("evaluated args")) => _;
      print(getOHeap(OH)) => _;
      readO(i) :: OH --> Method(names, e, cs);
      print(StringV("read method")) => _;
      print(getOHeap(OH)) => _;
      saveConstants(e, names, actualArgsVs) :: E, H, OH --> e' :: OH';
      print(StringV("saved constants")) => _;
      print(getOHeap(OH')) => _;
      {E, e} => e''; // add local env constants (dynamic scoping)
      {e', e''} => e'''; // add constants
      cs :: Env e''', H, OH' --> v; // add the parameter constant method to the env
      print(StringV("evalutated code")) => _;
      print(v) => _.

  MCallCanonical(NoPrefix(),receiver,ID(name),NoArgType(),NoArgs()) :: OH --> v :: OH
    where
      print(StringV("method call with receiver")) => _;
      
      receiver --> WrappedO(Object(_, _, receiverEnv)); // MCallImpl([Part(ID("a"),NoArgType(),NoArgs())])
      
      print(Binding(receiverEnv)) => _;
      print(getOHeap(OH)) => _;
      
      readName(name) :: Env receiverEnv --> i; // read address from receiver environment
      
      readO(i) :: OH --> Method(names, e, cs); // read method from heap
      
      cs :: Env {e, receiverEnv}, OH --> v; // merge env from method with object env and execute
      
      print(v) => _;
      
      print(NumV(i)) => _;
      
      Done() => v;
      
      print(StringV("==========")) => _. 

  MCallOp(NumV(i1),OperatorCF(s),NoArgType(),NumV(i2)) --> NumV(nativeIBinOp(s, i1, i2)).

  getParamNames(pList) :: E, H, OH --> paramNames :: E', H', OH'
    where
      print(StringV("getting param names")) => _;
      case pList of {
        Params([]) =>
          [] => paramNames;
          E => E';
          H => H';
          OH => OH'
        Params([Param(name, _) | [] ]) =>
          [name] => paramNames;
          E => E';
          H => H';
          OH => OH'
        Params([Param(name, _) | otherNames ]) =>
          getParamNames(Params(otherNames)) :: E, H, OH --> names :: E', H', OH';
          [ name | names ] => paramNames
      }.
      
  getParamNames(NoParams()) --> []
    where
      print(StringV("getting param names for NoParams()")) => _.

  MethodDecl(
    NoPrefix(),
    [MethodID(ID(name),NoArgType(),NoAnnotations(),
      ps // [Param(paramName,NoTypeAnn())]
    )],
    NoMethodType(),
    MethodBody(
      cs
    ),
    NoWhere()
  ) :: E, OH --> Done() :: Env e', OHeap OH'
    where
      print(StringV("Declaring method")) => _;
      print(getOHeap(OH)) => _;
      getParamNames(ps) :: E, OH --> pNames;
      fresh => i;
      {name |--> i, E} => eNew; // add itself to its own evironment
      print(StringV("writing")) => _;
      writeO(i, Method(pNames, eNew, cs)) :: OH --> _ :: OHeap OH'; 
      print(StringV("method written")) => _;
      bindName(name, i) :: E --> e'; // saves and returns done 
      
      print(Binding(E)) => _;
      print(Binding(eNew)) => _;
      print(Binding(e')) => _;
      print(StringV("==========")) => _. 
  
  // for now constants will just be a method returning the evaluated value
  Constant(name, _, _, e1) :: E, H, OH --> Done() :: E'', H'', OH''
    where
      print(StringV("Binding constant")) => _;
      print(getOHeap(OH)) => _;
      
      e1 :: E, H, OH --> v1 :: E', H', OH';
      
      print(getOHeap(OH')) => _;
      
      saveConstMethod(E, name, v1) :: E', H', OH' --> E'' :: H'', OH'';
      
      print(Binding(E')) => _;
      print(StringV("==========")) => _.

  O Object(_, _, eEnc) |- MCallWDot(Outer(),[Part(ID(name),NoArgType(),NoArgs())]) --> v
    where
      print(StringV("reading from outer")) => _;
      print(Binding(eEnc)) => _;
      eEnc[name] => i;
      print(NumV(i)) => _;
      read(i) => v;
      Done() => v. 
   
//  TraitDecl(
//    [MethodID(ID(mName), NoArgType(), NoAnnotations(), NoParams())],
//    MethodBody(cs)
//  ) -o-> Trait(e')
//    where
//      cs --> sm@Method(_, _, _);
//      bindName(mName, allocate(sm)) => e';
//      Trait(e') => t.
