module trans/semantics

imports
  src-gen/ds-signatures/Grace-sig
  src-gen/ds-signatures/Grace-lowered-sig
  
  trans/values
  trans/store
  trans/environment

signature

  arrows
    Program -init-> V
    
    Exp --> V
    Boolean --> V
    CodeSequence --> V
    Declaration --> V
    Assignment --> V
    CallArgs --> V
    List(CodeSequence) --> V
    Params --> List(String)
    
    Exp -o-> O
    Declaration -o-> O   
  
    List(Exp) -ea-> List(V)
    
  constructors
    saveConstMethod: Env * String * V --> Env
    getParamNames: Params --> List(String)
    saveConstants: Env * List(String) * List(V) --> Env
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    nativeIfThenElse: Bool * V * V -> V
    nativePrint: V -> V
    
rules

  Expression(e) --> e.
  Declaration(e) --> e.
  Wrapped(v) --> v.
  Assignment(e) --> e.

  Number(s) --> NumV(parseNumber(s)).
  ArgNumber(s) --> NumV(parseNumber(s)).
  ArgBoolean(True()) --> BoolV(true).
  ArgBoolean(False()) --> BoolV(false).
  ArgString(s) --> StringV(s).
  String(s) --> StringV(s).
  True() --> BoolV(true).
  False() --> BoolV(false).
  Boolean(s) --> s.

  Program(cs, _) -init-> cs'
    where
      O NoObject() |- cs :: Env {}, Heap {}, OHeap {} --> cs' :: Env _, Heap _, OHeap _.
  
  O encO |- ObjectDecl(NoInherit(), [], cs)  :: E, H, OH -->
                WrappedO(Object(Object(encO, NoObject(), E), NoObject(), E')) :: E', H', OH'
    where
      printS("directly evaluating object") => _;
      print(getOHeap(OH)) => _;
      O Object(encO, NoObject(), E) |- cs :: E, H, OH  --> _ :: E', H', OH';
      printS("done directly evaluating object") => _;
      print(getOHeap(OH')) => _;
      printS("==========") => _.
  
  cs : List(CodeSequence) :: E --> v' :: Env eFinal
  where
    print(StringV("executing codeseq")) => _;
    case cs of {
        [] =>
          print(StringV("emptylist")) => _;
          Done() => v';
          E => eFinal
        [code | [] ] =>  //needed for final value
          code :: E --> v' :: Env eFinal
        [code | cs'] =>
          print(StringV("one of many cs execs")) => _;
          print(Binding(E)) => _;
          code :: E --> v :: E';
          print(v) => _;
          print(StringV("first executed")) => _;
          cs' :: E' --> v' :: Env eFinal
        otherwise => 
          print(StringV("invalid cs")) => _;
          Done() => v;
          E => eFinal
    }.

  saveConstants(startEnv, names, values: List(V)) --> eFinal
    where
      print(StringV("saving constants")) => _;
      case names of {
        [] =>
          print(StringV("empty const list")) => _;
          startEnv => eFinal
        [n | ns] =>
          print(StringV("nonempty const list")) => _;
          values => [v|vs];
          print(Binding(startEnv)) => _;
          print(v) => _;
          print(StringV(n)) => _;
          saveConstMethod(startEnv, n, v) --> e;
          saveConstants(startEnv, ns, vs) --> em;
          {em, e} => eFinal
      }.
  
  saveConstMethod(startEnv, name, v) --> e'
    where 
      print(StringV("saving const method")) => _;
      fresh => i;
      writeO(i, Method([], startEnv, [Wrapped(v)])) --> _;
      bindName(name, i) --> e';
      print(StringV("==end saving const method==")) => _.
  
  [] : List(Exp) -ea-> []
    where
      print(StringV("ea 0")) => _.
  
  [arg] : List(Exp) -ea-> [v]
    where
      print(StringV("ea 1")) => _;
      arg --> v.
  
  [arg | more] : List(Exp) -ea-> [v | vs]
    where
      print(StringV("ea 1 and more")) => _;
      arg --> v;
      more -ea-> vs : List(V).
  
  MCallImplL(name, _, args) :: E --> v :: E
    where
      name != "base_print";
      name != "base_add";
      print(StringV("new method call on lowered")) => _;
      print(NumV(readName(name))) => _;
      readO(readName(name)) --> obj;
      print(Stored(obj)) => _;
      obj => Method(ns, e, cs);
      print(Binding(e)) => _;
      print(StringV("now evaluating args")) => _;
      args -ea-> vs;
      
      saveConstants(e, ns: List(String), vs: List(V)) --> e';
      
      cs :: Env {E, e'} --> v;
      print(StringV("==done new method call on lowered==")) => _.
      
  MCallImplL("base_print", _, [v]) :: E --> Done() :: E
    where
      nativePrint(v) => _.
  
  MCallImplL("base_add", _, [NumV(i1), NumV(i2)]) :: E --> v :: E
    where
      NumV(nativeIBinOp("+", i1, i2)) => v.

  MCallCanonical(NoPrefix(),receiver,ID(name),NoArgType(),NoArgs()) :: E, OH --> v :: E
    where
      printS("method call with receiver") => _;
      printS("startenv") => _;
      print(Binding(E)) => _;
      printS("startheap") => _;
      print(getOHeap(OH)) => _;
      
      receiver --> WrappedO(Object(_, _, receiverEnv)); // MCallImpl([Part(ID("a"),NoArgType(),NoArgs())])
      
      printS("receiverEnv") => _;
      print(Binding(receiverEnv)) => _;
      print(getOHeap(OH)) => _;
      
      readName(name) :: Env receiverEnv --> i; // read address from receiver environment
      
      readO(i) :: OH --> Method(names, e, cs); // read method from heap
      
      cs :: Env {e, receiverEnv}, OH --> v :: E''; // merge env from method with object env and execute
      
      print(v) => _;
      
      printI(i) => _;
      
//      Done() => v;
      
      printS("endenv") => _;
      print(Binding(E'')) => _;
      printS("==end method call with receiver==") => _. 

  MCallOp(NumV(i1),OperatorCF(s),NoArgType(),NumV(i2)) --> NumV(nativeIBinOp(s, i1, i2)).

  getParamNames(pList) --> paramNames
    where
      printS("getting param names") => _;
      case pList of {
        Params([]) =>
          [] => paramNames
        Params([Param(name, _) | [] ]) =>
          [name] => paramNames
        Params([Param(name, _) | otherNames ]) =>
          getParamNames(Params(otherNames)) --> names;
          [ name | names ] => paramNames
      }.
      
  getParamNames(NoParams()) --> []
    where
      printS("getting param names for NoParams()") => _.

  MethodDeclL(_, name, _, _, pNames, _, _, cs, _) :: E, OH --> Done() :: Env e'
    where
      printS("Declaring method") => _;
      print(getOHeap(OH)) => _;
      
      fresh => i;
      
      {name |--> i, E} => eNew; // add itself to its own evironment
      
      printS("writing") => _;
      
      writeO(i, Method(pNames, eNew, cs))--> _; 
      
      printS("method written") => _;
      
      bindName(name, i) --> e'; 
      
      print(Binding(E)) => _;
      print(Binding(eNew)) => _;
      print(Binding(e')) => _;
      printS("==========") => _. 
  
  // constants will just be a method returning the evaluated value
  Constant(name, _, _, e1) :: E --> Done() :: E''
    where
      saveConstMethod(E, name, e1) --> E''.

  O Object(_, _, eEnc) |- MCallWDot(Outer(),[Part(ID(name),NoArgType(),NoArgs())]) --> v
    where
      printS("reading from outer") => _;
      print(Binding(eEnc)) => _;
      eEnc[name] => i;
      printI(i) => _;
      read(i) => v;
      Done() => v. 
