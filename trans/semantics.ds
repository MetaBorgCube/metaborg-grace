module trans/semantics

imports
  src-gen/ds-signatures/Grace-sig
  
  trans/values
  trans/store
  trans/environment

signature
  
  constructors
    Object: Env * Env * List(CodeSequence) -> O // the enclosing object env, env of object, and its evaluted value
    Trait: Env -> V
    Method: Env * List(CodeSequence) -> V // env of declaration and code
    Binding: Env -> V
    NoObject: O
    
  arrows
    Exp --> V
    Exp -o-> O
    CodeSequence --> V
    Declaration --> V
    Assignment --> V
    CallArgs --> V
    List(CodeSequence) --> V
    Program -init-> V
    
  native operators
    nativeIBinOp: String * Int * Int -> Int
    
rules

  Program(cs, _) -init-> cs'
    where
      cs :: Env {"root" |--> fresh}, Heap {} --> cs' :: Heap _.
  
  Env eEnc |- ObjectDecl(Inherit(inhExp,_,_), [Use(useExp,_,_)], cs) :: E -o-> Object(eEnc, e', cs)
    where
      // 1. create empty object
      // 2. bind self (env + {})
      // 3. evalute inherit (recurse) and merge into
      // 4. evaluate traits and merge into (override inherit)
      // 5. evaluate local method definitions and merge (override inherit and traits)
      // 6. evaluate fields and statements. (deferred)
      Object(eEnc, E, cs) => self; // create blank object 1
      
      E |- bindName("self", allocateO(self)) --> eSelf; // 2
      
      inhExp :: Env eSelf -o-> Object(eInh, eInhEnc, csInh); // 3
      
      Env eInhEnc |- csInh :: Env eInh --> _ :: Env EAfterInh; //
      
      useExp :: Env eInh --> Trait(eTrait); // 4
      
      {eTrait, EAfterInh} => e'.
  
  
  // object can be immediatly evaluated
  Object(eEnc, e, cs) --> v
    where
      Env eEnc |- cs :: Env e --> v.

  Expression(e) --> e.
  Declaration(e) --> e.
  Assignment(e) --> e.
    
  cs : List(CodeSequence) :: Env e --> v :: Env eFinal
  where
    case cs of {
        [] =>
            Done() => v
        [code|[]] =>
            code :: Env e --> v :: Env eFinal
        [code | cs'] =>
            code :: Env e --> _ :: Env e';
            cs' :: Env e' --> v :: Env eFinal
    }.
  
  Number(s) --> NumV(parseNumber(s)).
  ArgNumber(s) --> NumV(parseNumber(s)).
  String(s) --> StringV(s).
  True() --> BoolV(true).
  False() --> BoolV(false).
  
  Constant(name, _, _, e1) --> Done() :: Env e'
    where
      e1 --> v1;
      print(StringV("Binding constant")) => _;
      print(v1) => _;
      bindName(name, allocate(v1)) --> e';
      print(StringV("After constant binding: ")) => _;
      print(Binding(e')) => _.

  // just an implicit method call with no args
  MCallImpl([Part(ID(name),NoArgType(),NoArgs())]) :: Env e --> v
    where
      print(StringV("reading from environment")) => _;
      print(Binding(e)) => _;
      readName(name) => i;
      print(NumV(i)) => _;
      read(i) => v;
      print(v) => _.

//  Variable(name, NoAnnotations(), NoTypeAnn(), VarInit(v1)) --> Done()
//    where
//      write(name, v1) --> _.
//      
//  Assignment(name, v1) --> Done()
//    where
//      write(name, v1) --> _.
  
//  MethodDecl(
//    NoPrefix(),
//    [MethodID(ID(name), NoArgType(), NoAnnotations(), NoParams())],
//    NoMethodType(),
//    MethodBody(cs),
//    NoWhere()
//  ) :: H --> Done() :: H
//    where
//      writeCode(name, StoredMethod([], cs, H)) -code-> _.
   
   MCallOp(NumV(i1),OperatorCF(s),NoArgType(),NumV(i2)) --> NumV(nativeIBinOp(s, i1, i2)).

   MethodDecl(
     NoPrefix(),
     [MethodID(ID(name),NoArgType(),NoAnnotations(),NoParams())],
     NoMethodType(),
     MethodBody(
       [Expression(ObjectDecl(NoInherit(),[], cs))]
     ),
     NoWhere()
   ) :: Env e --> Binding(bindName(name, allocate(Method(e, cs)))). // saves method and returns binding that includes this method
   
  TraitDecl(
    [MethodID(ID(mName), NoArgType(), NoAnnotations(), NoParams())],
    MethodBody(cs)
  ) --> t
    where
      cs --> sm@Method(_, _);
      bindName(mName, allocate(sm)) => e';
      Trait(e') => t.
  
  
   